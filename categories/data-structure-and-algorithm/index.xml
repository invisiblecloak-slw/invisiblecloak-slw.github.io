<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure and Algorithm on XIU</title>
    <link>https://qidi.ink/categories/data-structure-and-algorithm/</link>
    <description>Recent content in Data Structure and Algorithm on XIU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://qidi.ink/categories/data-structure-and-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0200-number of islands</title>
      <link>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</guid>
      <description>问题描述 给定一个由1(陆地)和0(水)组成的二维网格，计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，可以假设网格的四条边均被水包围。
 示例1
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;]]
输出: 1
 示例2
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;]]
输出: 3
 提示:
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为0或1   代码 class Solution: def numIslands(self, grid: List[List[str]]) -&amp;gt; int: cnt, self.</description>
    </item>
    
    <item>
      <title>0198-house robber</title>
      <link>https://qidi.ink/post/2021/04/20/0198-house-robber/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/20/0198-house-robber/</guid>
      <description>问题描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。
 示例1:
 输入: [1,2,3,1]
输出: 4
 示例2:
 输入: [2,7,9,3,1]
输出: 12
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 400   代码 class Solution: def rob(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) pre, cur = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): pre, cur = cur, max(cur, pre + nums[i]) return post 分析 本问题可以用动态规划的思想进行求解。</description>
    </item>
    
    <item>
      <title>0031-next permutation</title>
      <link>https://qidi.ink/post/2021/04/19/0031-next-permutation/</link>
      <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/19/0031-next-permutation/</guid>
      <description>问题描述 实现获取下一个排列的函数：将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数组重新排列盛最小的序列（即升序排列）。
考虑原地修改，且只使用额外常数空间。
 示例1
 输入: nums = [1,2,3]
输出: [1,3,2]
 示例2
 输入: nums = [3,2,1]
输出: [1,2,3]
 示例3
 输入: nums = [1,1,5]
输出: [1,5,1]
 示例4
 输入: nums = [1]
输出: [1]
 提示:
 1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 100   代码 pre = post = -1 for pos in range(len(nums) - 1, 0, -1): if nums[pos] &amp;gt; nums[pos - 1]: pre, post = pos - 1, pos break if post == -1: nums.</description>
    </item>
    
    <item>
      <title>0022-generate parentheses</title>
      <link>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</guid>
      <description>问题描述 设计函数，生成所有可能的并且有效的括号组合。
数字n代表生成括号的对数。
 示例1:
 输入: n = 3
输出: [&amp;quot;((()))&amp;quot;, &amp;ldquo;(()())&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, &amp;ldquo;()(())&amp;rdquo;, &amp;ldquo;()()()&amp;quot;]
 示例2:
 输入: n = 1
输出: [&amp;quot;()&amp;quot;]
 提示: 1 &amp;lt;= n &amp;lt;= 8
 代码 DFS1 class Solution: def helper(self, comb = &amp;#39;&amp;#39;, lcnt = 0, matched = 0) -&amp;gt; None: if matched == self.n: self.res.append(comb) elif matched == lcnt: self.helper(comb + &amp;#39;(&amp;#39;, lcnt + 1, matched) elif lcnt &amp;lt; self.n: self.</description>
    </item>
    
    <item>
      <title>0017-letter combinations of a phone number</title>
      <link>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</guid>
      <description>题目描述 给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。
给定数字到字母的映射如下（与电话按键相同）。
 示例1
 输入: digits = &amp;ldquo;23&amp;rdquo;
输出: [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;]
 示例2
 输入: digits = &amp;quot;&amp;quot;
输出: []
 示例3
 输入: digits = &amp;ldquo;2&amp;rdquo;
输出: [&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;]
 提示:
 0 &amp;lt;= digits.length &amp;lt;= 4 digits[i]是范围[&#39;2&#39;, &#39;9&#39;]的一个数字 答案可以按任意顺序返回   代码 BFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: digit = [str(x) for x in range(2, 10)] alphabet = [&amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] d = dict(zip(digit, alphabet)) queue = list() cnt = 0 for digit in digits: if not cnt: for alphabet in d[digit]: queue.</description>
    </item>
    
    <item>
      <title>0019-remove nth node from end of list</title>
      <link>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</guid>
      <description>删除链表的倒数第N个结点 给定一个链表，删除链表的倒数第n个结点，并返回链表的头结点。
 示例1
 输入: head = [1,2,3,4,5], n = 2
输出: [1,2,3,5]
 示例2
 输入: head = [1], n = 1
输出: []
 示例3
 输入: head = [1,2], n = 1
输出: [1]
 提示:
 链表中节点的数目为sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.</description>
    </item>
    
    <item>
      <title>0015-3sum</title>
      <link>https://qidi.ink/post/2021/04/16/0015-3sum/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/16/0015-3sum/</guid>
      <description>问题描述 给定包含n个整数的数组nums。
判断nums中是否存在三个元素a, b, c，使得a + b + c = 0？
找出所有和为0且不重复的三元组。
 示例1
 输入: nums = [-1, 0, 1, 2, -1, -4]
输出: [[-1, -1, 2], [-1, 0, 1]]
 示例2
 输入: nums = []
输出: []
 示例3
 输入: nums = [0]
输出: []
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  注意: 答案中不包含重复的三元组。
 代码 class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] if not nums or len(nums) &amp;lt;= 2: return res nums.</description>
    </item>
    
    <item>
      <title>0011-container with most water</title>
      <link>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</guid>
      <description>问题描述 给定n个非负整数a1,a2,...,an。每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。
 示例1
 输入: [1,8,6,2,5,4,8,3,7]
输出: 49
 示例2
 输入: [1,1]
输出: 1
 示例3
 输入: [4,3,2,1,4]
输出: 16
 示例4
 输入: [1,2,1]
输出: 2
 提示:
 n = height.length 2 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 3 * 104   代码 class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: l, r, res = 0, len(height) - 1, 0 while l &amp;lt; r: res = max(res, (r - l) * min(height[r], height[l])) if height[l] &amp;lt; height[r]: l += 1 elif height[l] &amp;gt; height[r]: r -= 1 else: l, r = l + 1, r - 1 return res 分析   使用双指针法搜索盛最多水时的容器边界。搜索过程中进行剪枝。</description>
    </item>
    
    <item>
      <title>0005-longest palindromic substring</title>
      <link>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</guid>
      <description>最长回文子串 给定字符串s，找到s中的最长回文子串。
 示例1：
 输入: s = &amp;ldquo;babad&amp;rdquo;
输出: &amp;ldquo;bab&amp;quot;或&amp;quot;aba&amp;rdquo;
 示例2：
 输入: s = &amp;ldquo;cbbd&amp;rdquo;
输出: &amp;ldquo;bb&amp;rdquo;
 示例3：
 输入: s = &amp;ldquo;a&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 示例4：
 输入: s = &amp;ldquo;ac&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 提示:
 1 &amp;lt;= s.length &amp;lt;= 1000 s仅由数字和英文字母（大写和/或小写）组成   代码 动态规划法 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) # 记录dp过程中发现的最长回文子串 start, stride = 0, 0 # step = 0, 默认为True dp = [[True for j in range(n)] for i in range(n)] # step = 1, 另一种构建块，进行判定 for in in range(n - 1): if s[i] == s[i+1]: start, stride = i, 1 else: dp[i][i+1] = False # step in [2, n-1], 进行判定 for step in range(2, n): for i in range(n - step): if not dp[i + 1][i + step - 1] or s[i] !</description>
    </item>
    
    <item>
      <title>0226-invert-binary-tree</title>
      <link>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</guid>
      <description>题目描述 翻转一棵二叉树。
 示例
 输入:
 4 / \ 2 7 / \ / \ 1 3 6 9  输出:
 4 / \ 7 2 / \ / \ 9 6 3 1    代码 递归 # Definition for a binary tree node # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.</description>
    </item>
    
    <item>
      <title>0234-palindrome linked list</title>
      <link>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</guid>
      <description>问题描述 请判断一个链表是否为回文链表
 示例1:
 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出: true
 示例2:
 输入: 1-&amp;gt;2
输出: false
 提示:考虑使用O(n)时间复杂度和O(1)空间复杂度。
 代码 将链表中的元素复制到数组中，借助数组元素的随机访问特性，使用双指针法判定是否为回文链表 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.val = val # self.next = next class Solution(self, head : ListNode) -&amp;gt; bool: ptr, array = head, list() while ptr: array.append(ptr.val) ptr = ptr.next lptr, rptr = 0, len(array) - 1 while lptr &amp;lt; rptr: if array[lptr] !</description>
    </item>
    
    <item>
      <title>0461-hamming distance</title>
      <link>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</guid>
      <description>问题描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数x和y，计算它们之间的汉明距离。
 示例
 输入: x = 1, y = 4
输出: 2
解释:
1 (0 0 0 1)
4 (0 1 0 0)
 注意: 0 &amp;lt;= x, y &amp;lt; 231
 代码 Brian W. Kernighan &amp;amp; Dennis M. Ritchie class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: cnt += 1 xor &amp;amp;= xor - 1 return cnt Circular shift class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: if xor &amp;amp; 1: cnt += 1 return cnt 分析 本问题体现了位运算中关于计1的技巧。</description>
    </item>
    
    <item>
      <title>0543-diameter of binary tree</title>
      <link>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</guid>
      <description>问题描述 给定一棵二叉树，计算它的直径长度。一棵二叉树的直径长度是指任意两个节点路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。
 示例
 输入:
 1 / \ 2 3 / \ 4 5  输出: 3
解释: 路径为[4,2,1,3]或[5,2,1,3]。
 注意:两节点之间的路径长度是以它们之间边的数目表示。
 代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.right = right class Solution: def calDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: left_depth, right_depth = self.</description>
    </item>
    
    <item>
      <title>0617-merge two binary trees</title>
      <link>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</guid>
      <description>问题描述 给定两个二叉树，想想当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL的节点将直接作为新二叉树的节点。
 示例
 输入:
 Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7  输出:
 3 / \ 4 5 / \ \ 5 4 7   注意:合并必须从两个树的根节点开始。
 代码 DFS算法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.</description>
    </item>
    
    <item>
      <title>0155-min stack</title>
      <link>https://qidi.ink/post/2021/04/11/0155-min-stack/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0155-min-stack/</guid>
      <description>题目描述 设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。
 push(x): 将元素x推入栈中 pop(): 删除栈顶的元素 top(): 获取栈顶元素 getMin(): 检索栈中的最小元素   示例
 输入:
[&amp;ldquo;MinStack&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;,&amp;ldquo;pop&amp;rdquo;,&amp;ldquo;top&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;]
[[],[-2],[0],[-3],[],[],[],[]]
输出:
[null,null,null,null,-3,null,0,-2]
解释:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -3.
minStack.pop();
minStack.top(); &amp;ndash;&amp;gt; 返回 0.
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -2.
 提示
 pop、top和getMin操作总是在非空栈上调用。   代码 class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here. &amp;#34;&amp;#34;&amp;#34; self.Minstack = [] def push(self, val: int) -&amp;gt; None: if not self.</description>
    </item>
    
    <item>
      <title>0206-reverse linked list</title>
      <link>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</guid>
      <description>问题描述 反转一个简单链表。
 示例:
 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
 提示:
 可以使用递归和迭代两种方式反转链表。
  代码 递归 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head rhead = self.reverseList(head.next) head.next.next, head.next = head, None return rhead 迭代 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.</description>
    </item>
    
    <item>
      <title>0283-move zeroes</title>
      <link>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</guid>
      <description>问题描述 给定数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。
 示例
 输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
 说明:
   必须在原数组上操作，不能拷贝额外的数组
  尽量减少操作次数
    代码 双指针 - 1 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: count = 0 for num in nums: if num: nums[count] = num count += 1 nums[count:] = [0] * len(nums[count:]) 双指针 - 2 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: i = 0 for j in range(len(nums)): if nums[j]: nums[i], nums[j] = nums[j], nums[i] i += 1 注: 在每一次循环之前，i左边的元素均非零。</description>
    </item>
    
    <item>
      <title>0448-find all numbers disappeared in an array</title>
      <link>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>找到所有数组中消失的数字 给定一个范围在 1 &amp;lt;= a[i] &amp;lt;= n(n = 数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在[1,n]范围之间没有出现在数组中的数字。
考虑不使用额外空间的时间复杂度为O(n)的算法。
 示例
 输入: [4,3,2,7,8,2,3,1]
输出: [5,6]
  代码 O(1)空间复杂度 class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: nums[(num-1) % n] += n for i, num in enumerate(nums): if num &amp;lt;= n: res.append(i+1) return res class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: if nums[abs(num)-1] &amp;gt; 0: nums[abs(num)-1] *= -1 for i, num in enumerate(nums): if num &amp;gt; 0: res.</description>
    </item>
    
    <item>
      <title>0160-intersection of two linked lists</title>
      <link>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</guid>
      <description>题目描述 编写一个程序，找到两个单链表相交的起始节点。
 示例1:
 输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出: Reference of the node with value = 8
输入解释: 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。链表A为[4,1,8,4,5]，链表B为[5,0,1,8,4,5]。在A中，相交节点前有2个节点；在B中，相交节点前有3个节点。
 示例2:
 输入: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Refernce of the node with value = 2
输入解释: 相交节点的值为 2 （注意，如果两个链表相交则不能为0）。链表A为[0,9,1,2,4]，链表B为[3,2,4]。在A中，相交节点前有3个节点；在B中，相交节点前有1个节点。
 示例3:
 输入: intersecVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</description>
    </item>
    
    <item>
      <title>0169-majority element</title>
      <link>https://qidi.ink/post/2021/04/10/0169-majority-element/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0169-majority-element/</guid>
      <description>多数元素 给定一个大小为n的数组，找到其中的多数元素。
多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。
可以假设数组是非空的，并且给定的数组总是存在多数元素。
 尝试使用时间复杂度为O(n)，空间复杂度为O(1)的算法解决此问题。   示例1
 输入: [3,2,3]
输出: 3
 示例2
 输入: [2,2,1,1,1,2,2]
输出: 2
  代码 Boyer-Moore 投票法 class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: winner, winner_counter = None, 0 for candidate in nums: if winner_counter == 0: winner = candidate winner_counter += 1 elif winner == candidate: winner_counter += 1 else: winner_counter -= 1 return winner 分析 Boyer-Moore 投票法 Moore投票法旨在解决：如何在任意多的候选人中，定出获得票数最多的候选人。</description>
    </item>
    
    <item>
      <title>0101-symmetric tree</title>
      <link>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</guid>
      <description>题目描述 给定一个二叉树，检查它是否是镜像对称的。
 示例1:
 输入:
 1 / \ 2 2 / \ / \ 3 4 4 3  输出: True
 示例2:
 输入:
 1 / \ 2 2 \ \ 3 3    代码: # 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSame(self, lptr:TreeNode, rptr:TreeNode) -&amp;gt; bool: if not lptr and not rptr: return True if not lptr or not rptr or lptr.</description>
    </item>
    
    <item>
      <title>0104-maximum depth of binary tree</title>
      <link>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根结点到最远叶子结点的最长路径上的节点数。
 示例:
给定二叉树[3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7  返回它的最大深度3。
说明: 叶子结点是指没有子节点的节点。
 代码 # 递归，深度优先遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: return 1 + max(self.maxDepth(root.left), self.</description>
    </item>
    
    <item>
      <title>0121-best time to buy and sell stock</title>
      <link>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</guid>
      <description>问题描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。
代码: class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = [0] * len(prices) for i in range(1, len(prices)): profit[i] = max(0, profit[i-1] + prices[i] - prices[i-1]) return max(profit) 分析:  本问题与最大子序和问题相似  </description>
    </item>
    
    <item>
      <title>0136-single nubmer</title>
      <link>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</guid>
      <description>问题描述  给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
示例1:
 输入: [2,2,1]
输出: 1
 示例2:
 输入: [4,1,2,1,2]
输出: 4
 说明:
考虑线性时间复杂度的原地算法。
 代码 # 异或运算 class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: return reduce(lambda x,y: x^y, nums) 分析 map/reduce:  map()函数接收两个参数，一为函数，一为Iterable。  map()将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。   reduce()函数接收两个参数，一为函数，一为序列。效果为：  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)    示例1:
 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小些的规范名字。
输入[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。
 list(map(lambda x: x.</description>
    </item>
    
    <item>
      <title>0141-linked list cycle</title>
      <link>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</guid>
      <description>问题描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回true。否则返回false。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: false
解释: 链表中没有环。
 提示:
 链表中节点的数目范围是[0, 104] -105 &amp;lt;= Node.val &amp;lt;= 105 pos 为 -1或者链表中的一个有效索引。   代码 # hashTable # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>0021-merge two sorted list</title>
      <link>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</guid>
      <description>题目描述  将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例1
 输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
 示例2
 输入: l1 = [], l2 = []
输出: []
 示例3
 输入: l1 = [], l2 = [0]
输出: [0]
 提示:
 两个链表的节点数目范围是[0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按非递减顺序排列   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>0053-maximum subarray</title>
      <link>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</guid>
      <description>题目描述  给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例1:
 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
 示例2:
 输入: nums = [1]
输出: 1
 示例3:
 输入: nums = [0]
输出: 0
 示例4:
 输入: nums = [-1]
输出: -1
 示例5:
 输入: nums = [-100000]
输出: -100000
 提示:
  1 &amp;lt;= nums.length &amp;lt;= 3 * 104
  -105 &amp;lt;= nums[i] &amp;lt;= 105
   代码 class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i-1] + nums[i]) return max(nums) 分析   考虑nums[i]，若nums[i-1]所存储的累加值为正，则对nums[i]有增益。从而以i结尾的子序和大于nums[i]。</description>
    </item>
    
    <item>
      <title>0070-climbing stairs</title>
      <link>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</guid>
      <description>问题描述
假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例1:
 输入: 2
输出: 2
解释: 有两种方法可以到达楼顶。
  1阶 + 1阶
  2阶
   示例2:
 输入: 3
输出: 3
解释:
  1阶 + 1阶 + 1阶
  1阶 + 2阶
  2阶 + 1阶
   注意:
给定n是一个正整数。
 代码 # 递归，超时 class Solution: def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt;= 2: return n else: return self.</description>
    </item>
    
    <item>
      <title>0002-add-two-numbers</title>
      <link>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</guid>
      <description>题目描述  给定两个非空的链表，表示两个非负整数。它们的每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。
请你将两个数字相加，并以相同形式返回一个表示和的链表
你可以假设除了数字0之外，这两个数都不会以0开头。
示例1
 输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
 示例2
 输入: l1 = [0], l2 = [0]
输出: [0]
 示例3
 输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
 提示
  每个链表中的节点数在范围[1, 100]内
  0 &amp;lt;= Node.val &amp;lt;= 9
  题目数据保证列表表示的数字不含前导零
   代码 # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>0003-longest substring without repeating characters</title>
      <link>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</guid>
      <description>题目描述  给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
示例1
 输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;abc&amp;quot;，所以其长度为3。
 示例2
 输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是&amp;quot;b&amp;quot;，所以其长度为1。
 示例3
 输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;wke&amp;quot;，所以其长度为3。
 示例4
 输入: s = &amp;quot;&amp;quot;
输出: 0
 提示
  0 &amp;lt;= s.length &amp;lt;= 5 * 104
  s由英文字母、数字、符号和空格组成
   代码 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: #考虑以某一下标为起始位置的最长子串。 l = r = maxlen = 0 hashtable = dict() #记录某一元素出现的最靠结尾的下标 while r in range(len(s)): if s[r] in hashtable and hashtable[s[r]] in range(l, r): l = hashtable[s[r]] + 1 hashtable[s[r]] = r maxlen = max(maxlen, r - l + 1) r += 1 return maxlen 分析  使用滑动窗方法处理子字符串  </description>
    </item>
    
    <item>
      <title>0020-Valid Parentheses</title>
      <link>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</guid>
      <description>问题描述  给定一个只包括&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;,&#39;]&#39;的字符串s，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  示例1:
 输入: s = &amp;ldquo;()&amp;rdquo;
输出: true
 示例2:
 输入: s = &amp;ldquo;()[]{}&amp;rdquo;
输出: true
 示例3:
 输入: s = &amp;ldquo;(]&amp;rdquo;
输出: false
 示例4:
 输入: s = &amp;ldquo;([)]&amp;rdquo;
输出: false
 示例5:
 输入: s = &amp;ldquo;{[]}&amp;rdquo;
输出:true
 提示:
  1 &amp;lt;= s.length &amp;lt;= 104
  s仅由括号()[]{}组成
   代码 class Solution: def isValid(self, s: str) -&amp;gt; bool: if len(s) % 2 == 1: return False dictionary = {&amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;} stack = [] for ch in s: if ch in dictionary: stack.</description>
    </item>
    
    <item>
      <title>0001-Two Sum</title>
      <link>https://qidi.ink/post/2021/04/06/0001-two-sum/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/0001-two-sum/</guid>
      <description>题目描述  给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例1
 输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]。
 示例2
 输入: nums = [3,2,4], target = 6
输出: [1,2]
 示例3
 输入: nums = [3,3], target = 6
输出: [0,1]
 提示
  2 &amp;lt;= nums.length &amp;lt;= 103
  只会存在一个有效答案
   代码 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashtable = dict() for i, val in enumerate(nums): if target - val in hashtable: return [hashtable[target - val], i] else: hashtable[val] = i 分析  使用哈希将查找元素的时间复杂度降至O(1)  </description>
    </item>
    
  </channel>
</rss>
