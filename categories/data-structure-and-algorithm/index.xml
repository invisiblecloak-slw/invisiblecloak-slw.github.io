<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structure and Algorithm on XIU</title>
    <link>https://qidi.ink/categories/data-structure-and-algorithm/</link>
    <description>Recent content in Data Structure and Algorithm on XIU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 07 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://qidi.ink/categories/data-structure-and-algorithm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0236-lowest common ancestor of a binary tree</title>
      <link>https://qidi.ink/post/2021/05/07/0236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/07/0236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>问题描述 给定二叉树，找到该树中两个指定节点的最近公共祖先。
最近公共祖先的的定义为：“对于有根树T的两个节点p和q，最近公共祖先表示为一个节点x，满足 x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）”。
 提示:
 树中节点数目在范围[2, 105]内。 -109 &amp;lt;= Node.val &amp;lt;= 109。 所有Node.val互不相同。 p != q p和q均存在于给定的二叉树中。   代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if not root: return None if root == p: return root if root == q: return root left = self.</description>
    </item>
    
    <item>
      <title>0337-house robber iii</title>
      <link>https://qidi.ink/post/2021/05/06/0337-house-robber-iii/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/06/0337-house-robber-iii/</guid>
      <description>问题描述 在一个房屋排列呈二叉树状的区域，小偷实施盗窃。
如果两个直接相连的房子同时被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷能够盗取的最高金额。
 示例1:
 输入: [3,2,3,null,3,null,1]
 3 / \ 2 3 \ \ 3 1  输出: 7
解释: 小偷一晚能够盗取的最高金额为3 + 3 + 1 = 7.
 示例2:
 输入: [3,4,5,1,3,null,1]
 3 / \ 4 5 / \ \ 1 3 1  输出: 9
解释: 小偷一晚能够盗取的最高金额为4 + 5 = 9.
  代码 递归+哈希（超时） # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.</description>
    </item>
    
    <item>
      <title>🚩 0114-flatten binary tree to linked list</title>
      <link>https://qidi.ink/post/2021/05/05/0114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/05/0114-flatten-binary-tree-to-linked-list/</guid>
      <description>问题描述 给定二叉树的根节点root，将它展开为一个单链表：
 展开后的单链表应该同样使用TreeNode，其中right子指针指向链表中下一个结点，而左子指针始终为null。 展开后的单链表应该与二叉树先序遍历顺序相同。   示例1:
 1 1 / \ \ 2 5 =&amp;gt; 2 / \ \ \ 3 4 6 3 \ 4 \ 5 \ 6   输入: root = [1,2,5,3,4,null,6]
输出: [1,null,2,null,3,null,4,null,5,null,6]
 示例2:
 输入: root = []
输出: []
 示例3:
 输入: root = [0]
输出: [0]
 提示:
 树中结点数在范围[0, 2000]内 -100 &amp;lt;= Node.val &amp;lt;= 100   代码 递归 # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>0152-maximum product subarray</title>
      <link>https://qidi.ink/post/2021/05/04/0152-maximum-product-subarray/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/04/0152-maximum-product-subarray/</guid>
      <description>问题描述 给定整数数组nums，找出数组中乘积最大的连续子数组对应的乘积。
 示例1:
 输入: [2,3,-2,4]
输出: 6
解释: 子数组[2,3]有最大乘积。
 示例2:
 输入: [-2,0,-1]
输出: 0
解释: 结果不能为2，因为[-2,-1]不是子数组。
 提示:
 nums至少包含一个数字。   代码 class Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: if len(nums) == 1: return nums[0] res = maxval = minval = nums[0] for num in nums[1:]: maxval, minval = max(num, maxval * num, minval * num), min(num, minval * num, maxval * num) res = max(res, maxval) return res 分析  记maxval和minval分别标识以当前元素结尾的子数组的最大连续乘积和以当前元素结尾的子数组的最小连续乘积。 采用动态规划的思路，即当前元素为num：  若num为正：  若maxval &amp;gt; 0，则maxval更新为maxval * num。 若maxval &amp;lt;= 0，则maxval更新为num。 若minval &amp;lt; 0，则minval更新为minval * num。 若minval &amp;gt;= 0，则minval更新为num。   若num为负：  若minval &amp;lt; 0，则maxval更新为minval * num。 若minval &amp;gt;= 0，则maxval更新为num。 若maxval &amp;gt; 0，则minval更新为maxval * num。 若maxval &amp;lt;= 0，则minval更新为num。   若num为零：  maxval更新为0。 minval更新为0。     上述分析内蕴条件maxval &amp;gt;= minval。 在一趟遍历的过程中用变量res记录各处maxval中的最大值。 注意到maxval取值在maxval * num、num、minval * num中取得。因此可以利用max函数从三者中取得最大值，从而避免较为复杂的if else讨论。  minval的更新同理。    参考链接 详细通俗的思路分析，多解法</description>
    </item>
    
    <item>
      <title>0139-word break</title>
      <link>https://qidi.ink/post/2021/05/03/0139-word-break/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/03/0139-word-break/</guid>
      <description>问题描述 给定一个非空字符串s和一个包含非空单词的列表wordDict，判定s是否可以被空格拆封为一个或多个在字典中出现的单词。
 说明：
 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。  示例1:
 输入: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;]
输出: true
 示例2:
 输入: s = &amp;quot;applepenpple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;]
输出: true
 示例3:
 输入: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;]
输出: false
  </description>
    </item>
    
    <item>
      <title>🚩 0142-linked list cycle ii</title>
      <link>https://qidi.ink/post/2021/05/03/0142-linked-list-cycle-ii/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/03/0142-linked-list-cycle-ii/</guid>
      <description>问题描述 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。
为了表示给定链表中的环，使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。 如果pos是-1，则在该链表中没有环。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: 返回索引为1的链表节点
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: 返回索引为0的链表节点
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: 返回null
解释: 链表中没有环。
 提示;
 链表中节点数目范围在[0, 104]内。 -105 &amp;lt;= None.val &amp;lt;= 105。 pos的值为-1或链表中的一个有效索引。 不允许修改给定的链表。 考虑使用O(1)空间复杂度解决此问题。   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>0039-combination sum</title>
      <link>https://qidi.ink/post/2021/05/02/0039-combination-sum/</link>
      <pubDate>Sun, 02 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/02/0039-combination-sum/</guid>
      <description>问题描述 给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。
candidates中的数字可以无限制重复被选取。
 说明:
 所有数字（包括target）都是正整数。 解集不能包含重复的组合。  示例1:
 输入: candidates = [2,3,6,7], target = 7
输出: [[7], [2,2,3]]
 示例2:
 输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2], [2,3,3], [3,5]]
 提示:
 1 &amp;lt;= candidates.length &amp;lt;= 30 1 &amp;lt;= candidates[i] &amp;lt;= 200 candidates中的每个元素都是独一无二的。 1 &amp;lt;= target &amp;lt;= 500   代码 class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: candidates.sort() res = list() def backtrack(begin: int, end: int, target: int, tmp: List[int]) -&amp;gt; None: for i in range(begin, end): if candidates[i] == target: res.</description>
    </item>
    
    <item>
      <title>0078-subsets</title>
      <link>https://qidi.ink/post/2021/05/01/0078-subsets/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/01/0078-subsets/</guid>
      <description>问题描述  给定整数数组nums，数组中的元素互不相同。 返回所有可能的子集（幂集）。 解集不能包含重复的子集。可以按任意顺序返回解集。   示例1
 输入: nums = [1,2,3]
输出: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
 示例2
 输入: nums = [0]
输出: [[], [0]]
 提示
 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums中的所有元素互不相同   代码 class Solution def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = list() def backtrack(index: int, tmp: List[int]) -&amp;gt; None: res.append(tmp[:]) for i in range(index, len(nums)): tmp += [nums[i]] backtrack(i+1, tmp) tmp.</description>
    </item>
    
    <item>
      <title>0690-employee importance</title>
      <link>https://qidi.ink/post/2021/05/01/0690-employee-importance/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/01/0690-employee-importance/</guid>
      <description>问题描述 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度和直系下属的id。
比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15，10，5。那么员工1的数据结构式[1,15,[2]]，员工2的数据结构是[2,10,[3]，员工3的数据结构是[3,5,[]]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。
 示例
 输入: [[1,5,[2,3]], [2,3,[]], [3,3,[]]], 1
输出: 11
 提示
 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000   代码 &amp;#34;&amp;#34;&amp;#34; # Definition for Employee. class Employee: def __init__(self, id: int, importance: int, subordinates: List[int]): self.id = id self.importance = importance self.subordinates = subordinates &amp;#34;&amp;#34;&amp;#34; class Solution: def getImportance(self, employees: List[&amp;#39;Employee&amp;#39;], id: int) -&amp;gt; int: if not employees: return 0 hashTable = dict() for index, employee in enumerate(employees): hashTable[employee.</description>
    </item>
    
    <item>
      <title>0046-permutations</title>
      <link>https://qidi.ink/post/2021/04/30/0046-permutations/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/30/0046-permutations/</guid>
      <description>问题描述 给定一个没有重复数字的序列，返回其所有可能的全排列。
 示例:
 输入: [1,2,3]
输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  代码 自研递归 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: if len(nums) == 1: return [nums] for i in range(len(nums)): for permutation in self.permute(nums[:i] + nums[i+1:]): res.append(permutation + [nums[i]]) return res 与自研代码思路相同，可读性更高 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: def DFS(nums: List[int], tmp: List[int]) -&amp;gt; List[List[int]]: if not nums: res.append(tmp) eles: for i, element in enumerate(nums): DFS(nums[:i] + nums[i+1:], tmp + [element]) res = list() DFS(nums, []) return res 标准回溯 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: def backtrack(nums: List[int], size: int, depth: int, used: List[bool], permutation: List[int]) -&amp;gt; List[List[int]]: if depth == size: res.</description>
    </item>
    
    <item>
      <title>0056-merge intervals</title>
      <link>https://qidi.ink/post/2021/04/29/0056-merge-intervals/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/29/0056-merge-intervals/</guid>
      <description>问题描述 以数组intervals表示若干个区间的集合，其中单个区间为intervals[i] = [start_i, end_i]。
要求合并所有的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
 示例1:
 输入: intervals = [[1,2], [2,6], [8,10], [15,18]]
输出: [[1,6], [8,10], [15,18]]
解释: 区间[1,3] 和[2,6]重叠，将它们合并为[1,6]。
 示例2:
 输入: intervals = [[1,4], [4,5]]
输出: [[1,5]]
解释: 区间[1,4] 和[4,5]可被视为重叠区间。
 提示:
 1 &amp;lt;= intervals.length &amp;lt;= 104 intervals[i].length == 2 0 &amp;lt;= start_i &amp;lt;= end_i &amp;lt;= 104   代码 class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort(key = lambda x: x[0]) res = [] for interval in intervals: if not res: res.</description>
    </item>
    
    <item>
      <title>🚩0105-construct binary tree from preorder and inorder traversal</title>
      <link>https://qidi.ink/post/2021/04/28/0105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/28/0105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>问题描述 根据一棵树的前序遍历与中序遍历构造二叉树。
 示例
 输入:
 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7]  输出:
 3 / \ 9 20 / \ 15 7   注:假定树中没有重复的元素
 代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; TreeNode: self.</description>
    </item>
    
    <item>
      <title>0049-group anagrams</title>
      <link>https://qidi.ink/post/2021/04/27/0049-group-anagrams/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/27/0049-group-anagrams/</guid>
      <description>问题描述 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排序不同的字符串。
 示例:
 输入: [&amp;lsquo;eat&amp;rsquo;, &amp;lsquo;tea&amp;rsquo;, &amp;lsquo;tan&amp;rsquo;, &amp;lsquo;ate&amp;rsquo;, &amp;lsquo;nat&amp;rsquo;, &amp;lsquo;bat&amp;rsquo;]
输出: [ [&amp;lsquo;ate&amp;rsquo;,&amp;lsquo;eat&amp;rsquo;,&amp;lsquo;tea&amp;rsquo;], [&amp;lsquo;nat&amp;rsquo;, &amp;lsquo;tan&amp;rsquo;], [&amp;lsquo;bat&amp;rsquo;] ]
 说明:
 所有输入均为小写字母。 不考虑答案输出的顺序。   代码 以排序后的字符串作为键 class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: hashTable = collections.defaultdict(list) for word in strs: hashTable[&amp;#39;&amp;#39;.join(sorted(word))].append(word) return list(hashTable.values()]) 以字符串中各字母的频次统计作为键 class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: hashTable = collections.default(list) for word in strs: cnt = [0] * 26 for ch in word: cnt[ord(ch) - ord(&amp;#39;a&amp;#39;)] += 1 hashTable[tuple(cnt)].</description>
    </item>
    
    <item>
      <title>0238-product of array except self</title>
      <link>https://qidi.ink/post/2021/04/26/0238-product-of-array-except-self/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/26/0238-product-of-array-except-self/</guid>
      <description>问题描述 给定长度为n的整数数组nums，其中n&amp;gt;1，返回输出数组output[i]等于nums中除nums[i]之外其余各元素的乘积。
 示例
 输入：[1,2,3,4]
输出：[24,12,8,6]
 提示：数目数据保证数组之中任意元素的全部前缀元素和后缀）甚至是整个数组）的乘积都在32位整数范围内。
说明：不要使用除法，且在O(n)时间复杂度哪完成此题。
进阶：老吕在常数空间复杂度内解决这一问题。（出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
 代码 class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) L, R, res = [1] * n, [1] * n, [1] * n for i in range(1, n): L[i] = nums[i-1] * L[i-1] for j in range(n-2, -1, -1): R[j] = R[j+1] * nums[j+1] for i in range(n): res[i] = L[i] * R[i] return res class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n R = 1 for i in range(1, n): res[i] = nums[i-1] * res[i-1] for j in range(n-1, -1, -1): res[j], R = res[j] * R, R * nums[j] return res 分析  直观上可以通过以下方式解决：计算数组全部元素之积，再对数组中的每个元素x，将乘积除以x求得除自身以外数组的乘积。  若输入数组中出现0，那么本方法将会失效。   不必计算数组全部元素之积再除以给定索引处的数字得到相应的答案。可以利用索引左侧所有数字的乘积和索引右侧所有数字的乘积（前缀与后缀）相乘得到答案。  参考链接 除自身以外数组的乘积</description>
    </item>
    
    <item>
      <title>0055-jump game</title>
      <link>https://qidi.ink/post/2021/04/25/0055-jump-game/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/25/0055-jump-game/</guid>
      <description>问题描述 给定非负整数数组nums，最初位于数组的第一个下标。
数组中的每个元素代表在该位置可以跳跃的最大长度。
判定是否可以到达最后一个下标。
 示例1：
 输入：nums = [2,3,1,1,4]
输出： true
解释： 可以先跳一步，从下标0到达下标1，然后再从下标1跳3步到达最后一个下标。
 示例2：
 输入： nums = [3,2,1,0,4]
输出: false
解释：无论怎样，总会到达下标为3的位置。但该下标的最大跳跃长度是0，所以永远不可能到达最后一个下标。
 提示：
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 0 &amp;lt;= nums[i] &amp;lt;= 105   代码 Forward class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: border = 0 for i, radius in enumerate(nums): if i &amp;lt;= border: if i + radius &amp;gt;= len(nums) - 1: return True if i + radius &amp;gt; border: border = i + radius else: return False return True Backward class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: target = len(nums) - 1 for i in range(len(nums) - 2, -1, -1): if i + nums[i] &amp;gt;= target: target = i return target == 0 分析 事实1：若位置i可达，则位置i之前的位置均可达。  nums[i]可视为位置i的可达半径。  以位置i为圆心，nums[i]为可达半径，张成一个可达圆。  只考虑圆abs(theta) &amp;lt;= 90度在横轴上的投影即可。   若各可达圆的并集的投影覆盖了横轴[0, n-1]的所有点，则最后一个位置可达。   若从前向后的遍历过程发现某个位置超出了当前的可达范围，则由事实1可知，最后一个位置无法到达。  从前向后的遍历过程不能够跃过某些点，因为某个点可能蕴含着更大的可达范围。   若遍历过程中发现可达范围已包含最后一个位置，则返回true。  事实2：若位置i可达，则可达圆包含位置i且最近临位置i的位置j一定可达。  事实2可用反证法证明：倘若位置j不可达，由位置i的可达性知，必存在位置k的可达圆包含位置i，又位置k的可达圆一定包含位置i，故矛盾，因此位置j可达。 假设最后一个位置可达，由事实2知，问题可转换为收敛圆包含最后一个位置的最近邻位置是否可达。并转换为具有相同结构的子问题。 这种可达性在传递过程中下标递减。因此若最后一个位置可达，则链条的最后一环将是位置0。 若反向传播过程中发现某个位置不可达，则说明最后一个位置不可达。  </description>
    </item>
    
    <item>
      <title>0048-rotate image</title>
      <link>https://qidi.ink/post/2021/04/24/0048-rotate-image/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/24/0048-rotate-image/</guid>
      <description>问题描述 给定一个n级矩阵matrix表示一个图像。请将图像顺时针旋转90度。
考虑原地旋转图像，即直接修改输入的二维数组，不借助另一个矩阵来旋转图像。
 示例1:
 输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出: matrix = [[7,4,1],[8,5,2],[9,6,3]]
 示例2:
 输入: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出: matrix = [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 示例3:
 输入: matrix = [[1]]
输出: matrix = [[1]]
 示例4:
 输入: matrix = [[1,2],[3,4]]
输出: matrix = [[3,1],[4,2]]
 提示:
 matrix.length == n matrix[i].length == n 1 &amp;lt;= n &amp;lt;= 20 -1000 &amp;lt;= matrix[i][j] &amp;lt;= 1000   代码 自研 class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: i, j = 0, len(matrix) - 1 while i &amp;lt; j: for k in range(i, j): matrix[i][k], matrix[k][j], matrix[j][j-k+i], matrix[j-k+i][i] = matrix[j-k+i], matrix[i][k], matrix[k][j], matrix[j][j-k+i] i += 1 j -= 1 用翻转代替旋转 class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: n = len(matrix) for i in range(n // 2): for j in range(n): matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j] for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 分析  对于行标、列标分别为row、col的元素matrix[row][col]，在旋转变换作用下将映射到matrix[col][n-1-row]。 对于水平翻转结合对称变换，可注意到元素matrix[row][col]先变换为matrix[n-1-row][col]，再变换为matrix[col][n-1-row]。故水平翻转结合对称变换等价于旋转变换。 也可以结合递归思想，由外向内地逐方框进行旋转变换。可以用i、j分别指向方框的最小行标（最小列标）、最大行标（最大列标）。结合下图可实现旋转变换。   </description>
    </item>
    
    <item>
      <title>0009-palindrome number</title>
      <link>https://qidi.ink/post/2021/04/23/0009-palindrome-number/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/23/0009-palindrome-number/</guid>
      <description>问题描述 给定整数x，如果x是一个回文整数，返回true，否则返回false。
 示例1:
 输入: x = 121
输出: true
 示例2:
 输入: x = -121
输出: false
 示例3:
 输入: x = 10
输出: false
 提示: -231 &amp;lt;= x &amp;lt;= 231 - 1
 代码 class Solution: def isPalindrome(self, x: int) -&amp;gt; bool: if x &amp;lt; 0: return False if x % 10 == 0 and x != 0: return False reverse_x = 0 while x &amp;gt; reverse_x: reverse_x = 10 * reverse_x + x % 10 x //= 10 return x == reverse_x or x == reverse_x // 10 参考链接 回文数</description>
    </item>
    
    <item>
      <title>0739-daily temperatures</title>
      <link>https://qidi.ink/post/2021/04/22/739/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/22/739/</guid>
      <description>问题描述 根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，在该位置用0代替。
 示例
 输入: temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
输出: [1, 1, 4, 2, 1, 1, 0, 0]
 提示: 气温列表长度的范围为[1, 30000]。每个气温的值均为华氏度，都是在[30, 100]范围内的整数。
 代码 class Solution: def dailyTemperatures(self, T: List[int]) -&amp;gt; List[int]: monotone_stack, res = list(), [0] * len(T) for i in range(len(T)): if not monotone_stack: monotone_stack.append(i) else: while monotone_stack and T[monotone_stack[-1]] &amp;lt; T[i]: res[monotone_stack[-1]] = i - monotone_stack[-1] monotone_stack.pop() monotone_stack.append(i) return res 分析   维护一个存储下标的单调栈，栈底至栈顶对应的温度依次递减。</description>
    </item>
    
    <item>
      <title>0200-number of islands</title>
      <link>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</guid>
      <description>问题描述 给定一个由1(陆地)和0(水)组成的二维网格，计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，可以假设网格的四条边均被水包围。
 示例1
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;]]
输出: 1
 示例2
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;]]
输出: 3
 提示:
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为0或1   代码 class Solution: def numIslands(self, grid: List[List[str]]) -&amp;gt; int: cnt, self.</description>
    </item>
    
    <item>
      <title>0198-house robber</title>
      <link>https://qidi.ink/post/2021/04/20/0198-house-robber/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/20/0198-house-robber/</guid>
      <description>问题描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。
 示例1:
 输入: [1,2,3,1]
输出: 4
 示例2:
 输入: [2,7,9,3,1]
输出: 12
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 400   代码 class Solution: def rob(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) pre, cur = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): pre, cur = cur, max(cur, pre + nums[i]) return post 分析 本问题可以用动态规划的思想进行求解。</description>
    </item>
    
    <item>
      <title>0031-next permutation</title>
      <link>https://qidi.ink/post/2021/04/19/0031-next-permutation/</link>
      <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/19/0031-next-permutation/</guid>
      <description>问题描述 实现获取下一个排列的函数：将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数组重新排列盛最小的序列（即升序排列）。
考虑原地修改，且只使用额外常数空间。
 示例1
 输入: nums = [1,2,3]
输出: [1,3,2]
 示例2
 输入: nums = [3,2,1]
输出: [1,2,3]
 示例3
 输入: nums = [1,1,5]
输出: [1,5,1]
 示例4
 输入: nums = [1]
输出: [1]
 提示:
 1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 100   代码 pre = post = -1 for pos in range(len(nums) - 1, 0, -1): if nums[pos] &amp;gt; nums[pos - 1]: pre, post = pos - 1, pos break if post == -1: nums.</description>
    </item>
    
    <item>
      <title>0022-generate parentheses</title>
      <link>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</guid>
      <description>问题描述 设计函数，生成所有可能的并且有效的括号组合。
数字n代表生成括号的对数。
 示例1:
 输入: n = 3
输出: [&amp;quot;((()))&amp;quot;, &amp;ldquo;(()())&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, &amp;ldquo;()(())&amp;rdquo;, &amp;ldquo;()()()&amp;quot;]
 示例2:
 输入: n = 1
输出: [&amp;quot;()&amp;quot;]
 提示: 1 &amp;lt;= n &amp;lt;= 8
 代码 DFS1 class Solution: def helper(self, comb = &amp;#39;&amp;#39;, lcnt = 0, matched = 0) -&amp;gt; None: if matched == self.n: self.res.append(comb) elif matched == lcnt: self.helper(comb + &amp;#39;(&amp;#39;, lcnt + 1, matched) elif lcnt &amp;lt; self.n: self.</description>
    </item>
    
    <item>
      <title>0017-letter combinations of a phone number</title>
      <link>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</guid>
      <description>题目描述 给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。
给定数字到字母的映射如下（与电话按键相同）。
 示例1
 输入: digits = &amp;ldquo;23&amp;rdquo;
输出: [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;]
 示例2
 输入: digits = &amp;quot;&amp;quot;
输出: []
 示例3
 输入: digits = &amp;ldquo;2&amp;rdquo;
输出: [&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;]
 提示:
 0 &amp;lt;= digits.length &amp;lt;= 4 digits[i]是范围[&#39;2&#39;, &#39;9&#39;]的一个数字 答案可以按任意顺序返回   代码 BFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: digit = [str(x) for x in range(2, 10)] alphabet = [&amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] d = dict(zip(digit, alphabet)) queue = list() cnt = 0 for digit in digits: if not cnt: for alphabet in d[digit]: queue.</description>
    </item>
    
    <item>
      <title>0019-remove nth node from end of list</title>
      <link>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</guid>
      <description>删除链表的倒数第N个结点 给定一个链表，删除链表的倒数第n个结点，并返回链表的头结点。
 示例1
 输入: head = [1,2,3,4,5], n = 2
输出: [1,2,3,5]
 示例2
 输入: head = [1], n = 1
输出: []
 示例3
 输入: head = [1,2], n = 1
输出: [1]
 提示:
 链表中节点的数目为sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.</description>
    </item>
    
    <item>
      <title>0015-3sum</title>
      <link>https://qidi.ink/post/2021/04/16/0015-3sum/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/16/0015-3sum/</guid>
      <description>问题描述 给定包含n个整数的数组nums。
判断nums中是否存在三个元素a, b, c，使得a + b + c = 0？
找出所有和为0且不重复的三元组。
 示例1
 输入: nums = [-1, 0, 1, 2, -1, -4]
输出: [[-1, -1, 2], [-1, 0, 1]]
 示例2
 输入: nums = []
输出: []
 示例3
 输入: nums = [0]
输出: []
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  注意: 答案中不包含重复的三元组。
 代码 class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] if not nums or len(nums) &amp;lt;= 2: return res nums.</description>
    </item>
    
    <item>
      <title>0011-container with most water</title>
      <link>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</guid>
      <description>问题描述 给定n个非负整数a1,a2,...,an。每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。
 示例1
 输入: [1,8,6,2,5,4,8,3,7]
输出: 49
 示例2
 输入: [1,1]
输出: 1
 示例3
 输入: [4,3,2,1,4]
输出: 16
 示例4
 输入: [1,2,1]
输出: 2
 提示:
 n = height.length 2 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 3 * 104   代码 class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: l, r, res = 0, len(height) - 1, 0 while l &amp;lt; r: res = max(res, (r - l) * min(height[r], height[l])) if height[l] &amp;lt; height[r]: l += 1 elif height[l] &amp;gt; height[r]: r -= 1 else: l, r = l + 1, r - 1 return res 分析   使用双指针法搜索盛最多水时的容器边界。搜索过程中进行剪枝。</description>
    </item>
    
    <item>
      <title>0005-longest palindromic substring</title>
      <link>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</guid>
      <description>最长回文子串 给定字符串s，找到s中的最长回文子串。
 示例1：
 输入: s = &amp;ldquo;babad&amp;rdquo;
输出: &amp;ldquo;bab&amp;quot;或&amp;quot;aba&amp;rdquo;
 示例2：
 输入: s = &amp;ldquo;cbbd&amp;rdquo;
输出: &amp;ldquo;bb&amp;rdquo;
 示例3：
 输入: s = &amp;ldquo;a&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 示例4：
 输入: s = &amp;ldquo;ac&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 提示:
 1 &amp;lt;= s.length &amp;lt;= 1000 s仅由数字和英文字母（大写和/或小写）组成   代码 动态规划法 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) # 记录dp过程中发现的最长回文子串 start, stride = 0, 0 # step = 0, 默认为True dp = [[True for j in range(n)] for i in range(n)] # step = 1, 另一种构建块，进行判定 for in in range(n - 1): if s[i] == s[i+1]: start, stride = i, 1 else: dp[i][i+1] = False # step in [2, n-1], 进行判定 for step in range(2, n): for i in range(n - step): if not dp[i + 1][i + step - 1] or s[i] !</description>
    </item>
    
    <item>
      <title>0226-invert-binary-tree</title>
      <link>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</guid>
      <description>题目描述 翻转一棵二叉树。
 示例
 输入:
 4 / \ 2 7 / \ / \ 1 3 6 9  输出:
 4 / \ 7 2 / \ / \ 9 6 3 1    代码 递归 # Definition for a binary tree node # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.</description>
    </item>
    
    <item>
      <title>0234-palindrome linked list</title>
      <link>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</guid>
      <description>问题描述 请判断一个链表是否为回文链表
 示例1:
 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出: true
 示例2:
 输入: 1-&amp;gt;2
输出: false
 提示:考虑使用O(n)时间复杂度和O(1)空间复杂度。
 代码 将链表中的元素复制到数组中，借助数组元素的随机访问特性，使用双指针法判定是否为回文链表 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.val = val # self.next = next class Solution(self, head : ListNode) -&amp;gt; bool: ptr, array = head, list() while ptr: array.append(ptr.val) ptr = ptr.next lptr, rptr = 0, len(array) - 1 while lptr &amp;lt; rptr: if array[lptr] !</description>
    </item>
    
    <item>
      <title>0461-hamming distance</title>
      <link>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</guid>
      <description>问题描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数x和y，计算它们之间的汉明距离。
 示例
 输入: x = 1, y = 4
输出: 2
解释:
1 (0 0 0 1)
4 (0 1 0 0)
 注意: 0 &amp;lt;= x, y &amp;lt; 231
 代码 Brian W. Kernighan &amp;amp; Dennis M. Ritchie class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: cnt += 1 xor &amp;amp;= xor - 1 return cnt Circular shift class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: if xor &amp;amp; 1: cnt += 1 return cnt 分析 本问题体现了位运算中关于计1的技巧。</description>
    </item>
    
    <item>
      <title>0543-diameter of binary tree</title>
      <link>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</guid>
      <description>问题描述 给定一棵二叉树，计算它的直径长度。一棵二叉树的直径长度是指任意两个节点路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。
 示例
 输入:
 1 / \ 2 3 / \ 4 5  输出: 3
解释: 路径为[4,2,1,3]或[5,2,1,3]。
 注意:两节点之间的路径长度是以它们之间边的数目表示。
 代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.right = right class Solution: def calDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: left_depth, right_depth = self.</description>
    </item>
    
    <item>
      <title>0617-merge two binary trees</title>
      <link>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</guid>
      <description>问题描述 给定两个二叉树，想想当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL的节点将直接作为新二叉树的节点。
 示例
 输入:
 Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7  输出:
 3 / \ 4 5 / \ \ 5 4 7   注意:合并必须从两个树的根节点开始。
 代码 DFS算法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.</description>
    </item>
    
    <item>
      <title>0155-min stack</title>
      <link>https://qidi.ink/post/2021/04/11/0155-min-stack/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0155-min-stack/</guid>
      <description>题目描述 设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。
 push(x): 将元素x推入栈中 pop(): 删除栈顶的元素 top(): 获取栈顶元素 getMin(): 检索栈中的最小元素   示例
 输入:
[&amp;ldquo;MinStack&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;,&amp;ldquo;pop&amp;rdquo;,&amp;ldquo;top&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;]
[[],[-2],[0],[-3],[],[],[],[]]
输出:
[null,null,null,null,-3,null,0,-2]
解释:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -3.
minStack.pop();
minStack.top(); &amp;ndash;&amp;gt; 返回 0.
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -2.
 提示
 pop、top和getMin操作总是在非空栈上调用。   代码 class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here. &amp;#34;&amp;#34;&amp;#34; self.Minstack = [] def push(self, val: int) -&amp;gt; None: if not self.</description>
    </item>
    
    <item>
      <title>0206-reverse linked list</title>
      <link>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</guid>
      <description>问题描述 反转一个简单链表。
 示例:
 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
 提示:
 可以使用递归和迭代两种方式反转链表。
  代码 递归 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head rhead = self.reverseList(head.next) head.next.next, head.next = head, None return rhead 迭代 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.</description>
    </item>
    
    <item>
      <title>0283-move zeroes</title>
      <link>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</guid>
      <description>问题描述 给定数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。
 示例
 输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
 说明:
   必须在原数组上操作，不能拷贝额外的数组
  尽量减少操作次数
    代码 双指针 - 1 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: count = 0 for num in nums: if num: nums[count] = num count += 1 nums[count:] = [0] * len(nums[count:]) 双指针 - 2 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: i = 0 for j in range(len(nums)): if nums[j]: nums[i], nums[j] = nums[j], nums[i] i += 1 注: 在每一次循环之前，i左边的元素均非零。</description>
    </item>
    
    <item>
      <title>0448-find all numbers disappeared in an array</title>
      <link>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>找到所有数组中消失的数字 给定一个范围在 1 &amp;lt;= a[i] &amp;lt;= n(n = 数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在[1,n]范围之间没有出现在数组中的数字。
考虑不使用额外空间的时间复杂度为O(n)的算法。
 示例
 输入: [4,3,2,7,8,2,3,1]
输出: [5,6]
  代码 O(1)空间复杂度 class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: nums[(num-1) % n] += n for i, num in enumerate(nums): if num &amp;lt;= n: res.append(i+1) return res class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: if nums[abs(num)-1] &amp;gt; 0: nums[abs(num)-1] *= -1 for i, num in enumerate(nums): if num &amp;gt; 0: res.</description>
    </item>
    
    <item>
      <title>0160-intersection of two linked lists</title>
      <link>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</guid>
      <description>题目描述 编写一个程序，找到两个单链表相交的起始节点。
 示例1:
 输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出: Reference of the node with value = 8
输入解释: 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。链表A为[4,1,8,4,5]，链表B为[5,0,1,8,4,5]。在A中，相交节点前有2个节点；在B中，相交节点前有3个节点。
 示例2:
 输入: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Refernce of the node with value = 2
输入解释: 相交节点的值为 2 （注意，如果两个链表相交则不能为0）。链表A为[0,9,1,2,4]，链表B为[3,2,4]。在A中，相交节点前有3个节点；在B中，相交节点前有1个节点。
 示例3:
 输入: intersecVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</description>
    </item>
    
    <item>
      <title>0169-majority element</title>
      <link>https://qidi.ink/post/2021/04/10/0169-majority-element/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0169-majority-element/</guid>
      <description>多数元素 给定一个大小为n的数组，找到其中的多数元素。
多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。
可以假设数组是非空的，并且给定的数组总是存在多数元素。
 尝试使用时间复杂度为O(n)，空间复杂度为O(1)的算法解决此问题。   示例1
 输入: [3,2,3]
输出: 3
 示例2
 输入: [2,2,1,1,1,2,2]
输出: 2
  代码 Boyer-Moore 投票法 class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: winner, winner_counter = None, 0 for candidate in nums: if winner_counter == 0: winner = candidate winner_counter += 1 elif winner == candidate: winner_counter += 1 else: winner_counter -= 1 return winner 分析 Boyer-Moore 投票法 Moore投票法旨在解决：如何在任意多的候选人中，定出获得票数最多的候选人。</description>
    </item>
    
    <item>
      <title>0101-symmetric tree</title>
      <link>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</guid>
      <description>题目描述 给定一个二叉树，检查它是否是镜像对称的。
 示例1:
 输入:
 1 / \ 2 2 / \ / \ 3 4 4 3  输出: True
 示例2:
 输入:
 1 / \ 2 2 \ \ 3 3    代码: # 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSame(self, lptr:TreeNode, rptr:TreeNode) -&amp;gt; bool: if not lptr and not rptr: return True if not lptr or not rptr or lptr.</description>
    </item>
    
    <item>
      <title>0104-maximum depth of binary tree</title>
      <link>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根结点到最远叶子结点的最长路径上的节点数。
 示例:
给定二叉树[3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7  返回它的最大深度3。
说明: 叶子结点是指没有子节点的节点。
 代码 # 递归，深度优先遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: return 1 + max(self.maxDepth(root.left), self.</description>
    </item>
    
    <item>
      <title>0121-best time to buy and sell stock</title>
      <link>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</guid>
      <description>问题描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。
代码: class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = [0] * len(prices) for i in range(1, len(prices)): profit[i] = max(0, profit[i-1] + prices[i] - prices[i-1]) return max(profit) 分析:  本问题与最大子序和问题相似  </description>
    </item>
    
    <item>
      <title>0136-single nubmer</title>
      <link>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</guid>
      <description>问题描述  给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
示例1:
 输入: [2,2,1]
输出: 1
 示例2:
 输入: [4,1,2,1,2]
输出: 4
 说明:
考虑线性时间复杂度的原地算法。
 代码 # 异或运算 class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: return reduce(lambda x,y: x^y, nums) 分析 map/reduce:  map()函数接收两个参数，一为函数，一为Iterable。  map()将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。   reduce()函数接收两个参数，一为函数，一为序列。效果为：  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)    示例1:
 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小些的规范名字。
输入[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。
 list(map(lambda x: x.</description>
    </item>
    
    <item>
      <title>0141-linked list cycle</title>
      <link>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</guid>
      <description>问题描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回true。否则返回false。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: false
解释: 链表中没有环。
 提示:
 链表中节点的数目范围是[0, 104] -105 &amp;lt;= Node.val &amp;lt;= 105 pos 为 -1或者链表中的一个有效索引。   代码 # hashTable # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>0021-merge two sorted list</title>
      <link>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</guid>
      <description>题目描述  将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例1
 输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
 示例2
 输入: l1 = [], l2 = []
输出: []
 示例3
 输入: l1 = [], l2 = [0]
输出: [0]
 提示:
 两个链表的节点数目范围是[0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按非递减顺序排列   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>0053-maximum subarray</title>
      <link>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</guid>
      <description>题目描述  给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例1:
 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
 示例2:
 输入: nums = [1]
输出: 1
 示例3:
 输入: nums = [0]
输出: 0
 示例4:
 输入: nums = [-1]
输出: -1
 示例5:
 输入: nums = [-100000]
输出: -100000
 提示:
  1 &amp;lt;= nums.length &amp;lt;= 3 * 104
  -105 &amp;lt;= nums[i] &amp;lt;= 105
   代码 class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i-1] + nums[i]) return max(nums) 分析   考虑nums[i]，若nums[i-1]所存储的累加值为正，则对nums[i]有增益。从而以i结尾的子序和大于nums[i]。</description>
    </item>
    
    <item>
      <title>0070-climbing stairs</title>
      <link>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</guid>
      <description>问题描述
假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例1:
 输入: 2
输出: 2
解释: 有两种方法可以到达楼顶。
  1阶 + 1阶
  2阶
   示例2:
 输入: 3
输出: 3
解释:
  1阶 + 1阶 + 1阶
  1阶 + 2阶
  2阶 + 1阶
   注意:
给定n是一个正整数。
 代码 # 递归，超时 class Solution: def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt;= 2: return n else: return self.</description>
    </item>
    
    <item>
      <title>0002-add-two-numbers</title>
      <link>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</guid>
      <description>题目描述  给定两个非空的链表，表示两个非负整数。它们的每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。
请你将两个数字相加，并以相同形式返回一个表示和的链表
你可以假设除了数字0之外，这两个数都不会以0开头。
示例1
 输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
 示例2
 输入: l1 = [0], l2 = [0]
输出: [0]
 示例3
 输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
 提示
  每个链表中的节点数在范围[1, 100]内
  0 &amp;lt;= Node.val &amp;lt;= 9
  题目数据保证列表表示的数字不含前导零
   代码 # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>0003-longest substring without repeating characters</title>
      <link>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</guid>
      <description>题目描述  给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
示例1
 输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;abc&amp;quot;，所以其长度为3。
 示例2
 输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是&amp;quot;b&amp;quot;，所以其长度为1。
 示例3
 输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;wke&amp;quot;，所以其长度为3。
 示例4
 输入: s = &amp;quot;&amp;quot;
输出: 0
 提示
  0 &amp;lt;= s.length &amp;lt;= 5 * 104
  s由英文字母、数字、符号和空格组成
   代码 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: #考虑以某一下标为起始位置的最长子串。 l = r = maxlen = 0 hashtable = dict() #记录某一元素出现的最靠结尾的下标 while r in range(len(s)): if s[r] in hashtable and hashtable[s[r]] in range(l, r): l = hashtable[s[r]] + 1 hashtable[s[r]] = r maxlen = max(maxlen, r - l + 1) r += 1 return maxlen 分析  使用滑动窗方法处理子字符串  </description>
    </item>
    
    <item>
      <title>0020-Valid Parentheses</title>
      <link>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</guid>
      <description>问题描述  给定一个只包括&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;,&#39;]&#39;的字符串s，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  示例1:
 输入: s = &amp;ldquo;()&amp;rdquo;
输出: true
 示例2:
 输入: s = &amp;ldquo;()[]{}&amp;rdquo;
输出: true
 示例3:
 输入: s = &amp;ldquo;(]&amp;rdquo;
输出: false
 示例4:
 输入: s = &amp;ldquo;([)]&amp;rdquo;
输出: false
 示例5:
 输入: s = &amp;ldquo;{[]}&amp;rdquo;
输出:true
 提示:
  1 &amp;lt;= s.length &amp;lt;= 104
  s仅由括号()[]{}组成
   代码 class Solution: def isValid(self, s: str) -&amp;gt; bool: if len(s) % 2 == 1: return False dictionary = {&amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;} stack = [] for ch in s: if ch in dictionary: stack.</description>
    </item>
    
    <item>
      <title>0001-Two Sum</title>
      <link>https://qidi.ink/post/2021/04/06/0001-two-sum/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/0001-two-sum/</guid>
      <description>题目描述  给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例1
 输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]。
 示例2
 输入: nums = [3,2,4], target = 6
输出: [1,2]
 示例3
 输入: nums = [3,3], target = 6
输出: [0,1]
 提示
  2 &amp;lt;= nums.length &amp;lt;= 103
  只会存在一个有效答案
   代码 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashtable = dict() for i, val in enumerate(nums): if target - val in hashtable: return [hashtable[target - val], i] else: hashtable[val] = i 分析  使用哈希将查找元素的时间复杂度降至O(1)  </description>
    </item>
    
  </channel>
</rss>
