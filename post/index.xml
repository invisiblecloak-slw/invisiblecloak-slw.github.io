<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on XIU</title>
    <link>https://qidi.ink/post/</link>
    <description>Recent content in Posts on XIU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 26 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://qidi.ink/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0238-product of array except self</title>
      <link>https://qidi.ink/post/2021/04/26/0238-product-of-array-except-self/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/26/0238-product-of-array-except-self/</guid>
      <description>问题描述 给定长度为n的整数数组nums，其中n&amp;gt;1，返回输出数组output[i]等于nums中除nums[i]之外其余各元素的乘积。
 示例
 输入：[1,2,3,4]
输出：[24,12,8,6]
 提示：数目数据保证数组之中任意元素的全部前缀元素和后缀）甚至是整个数组）的乘积都在32位整数范围内。
说明：不要使用除法，且在O(n)时间复杂度哪完成此题。
进阶：老吕在常数空间复杂度内解决这一问题。（出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
 代码 class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) L, R, res = [1] * n, [1] * n, [1] * n for i in range(1, n): L[i] = nums[i-1] * L[i-1] for j in range(n-2, -1, -1): R[j] = R[j+1] * nums[j+1] for i in range(n): res[i] = L[i] * R[i] return res class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n R = 1 for i in range(1, n): res[i] = nums[i-1] * res[i-1] for j in range(n-1, -1, -1): res[j], R = res[j] * R, R * nums[j] return res 分析  直观上可以通过以下方式解决：计算数组全部元素之积，再对数组中的每个元素x，将乘积除以x求得除自身以外数组的乘积。  若输入数组中出现0，那么本方法将会失效。   不必计算数组全部元素之积再除以给定索引处的数字得到相应的答案。可以利用索引左侧所有数字的乘积和索引右侧所有数字的乘积（前缀与后缀）相乘得到答案。  参考链接 除自身以外数组的乘积</description>
    </item>
    
    <item>
      <title>0055-jump game</title>
      <link>https://qidi.ink/post/2021/04/25/0055-jump-game/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/25/0055-jump-game/</guid>
      <description>问题描述 给定非负整数数组nums，最初位于数组的第一个下标。
数组中的每个元素代表在该位置可以跳跃的最大长度。
判定是否可以到达最后一个下标。
 示例1：
 输入：nums = [2,3,1,1,4]
输出： true
解释： 可以先跳一步，从下标0到达下标1，然后再从下标1跳3步到达最后一个下标。
 示例2：
 输入： nums = [3,2,1,0,4]
输出: false
解释：无论怎样，总会到达下标为3的位置。但该下标的最大跳跃长度是0，所以永远不可能到达最后一个下标。
 提示：
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 0 &amp;lt;= nums[i] &amp;lt;= 105   代码 Forward class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: border = 0 for i, radius in enumerate(nums): if i &amp;lt;= border: if i + radius &amp;gt;= len(nums) - 1: return True if i + radius &amp;gt; border: border = i + radius else: return False return True Backward class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: target = len(nums) - 1 for i in range(len(nums) - 2, -1, -1): if i + nums[i] &amp;gt;= target: target = i return target == 0 分析 事实1：若位置i可达，则位置i之前的位置均可达。  nums[i]可视为位置i的可达半径。  以位置i为圆心，nums[i]为可达半径，张成一个可达圆。  只考虑圆abs(theta) &amp;lt;= 90度在横轴上的投影即可。   若各可达圆的并集的投影覆盖了横轴[0, n-1]的所有点，则最后一个位置可达。   若从前向后的遍历过程发现某个位置超出了当前的可达范围，则由事实1可知，最后一个位置无法到达。  从前向后的遍历过程不能够跃过某些点，因为某个点可能蕴含着更大的可达范围。   若遍历过程中发现可达范围已包含最后一个位置，则返回true。  事实2：若位置i可达，则可达圆包含位置i且最近临位置i的位置j一定可达。  事实2可用反证法证明：倘若位置j不可达，由位置i的可达性知，必存在位置k的可达圆包含位置i，又位置k的可达圆一定包含位置i，故矛盾，因此位置j可达。 假设最后一个位置可达，由事实2知，问题可转换为收敛圆包含最后一个位置的最近邻位置是否可达。并转换为具有相同结构的子问题。 这种可达性在传递过程中下标递减。因此若最后一个位置可达，则链条的最后一环将是位置0。 若反向传播过程中发现某个位置不可达，则说明最后一个位置不可达。  </description>
    </item>
    
    <item>
      <title>0048-rotate image</title>
      <link>https://qidi.ink/post/2021/04/24/0048-rotate-image/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/24/0048-rotate-image/</guid>
      <description>问题描述 给定一个n级矩阵matrix表示一个图像。请将图像顺时针旋转90度。
考虑原地旋转图像，即直接修改输入的二维数组，不借助另一个矩阵来旋转图像。
 示例1:
 输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出: matrix = [[7,4,1],[8,5,2],[9,6,3]]
 示例2:
 输入: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出: matrix = [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 示例3:
 输入: matrix = [[1]]
输出: matrix = [[1]]
 示例4:
 输入: matrix = [[1,2],[3,4]]
输出: matrix = [[3,1],[4,2]]
 提示:
 matrix.length == n matrix[i].length == n 1 &amp;lt;= n &amp;lt;= 20 -1000 &amp;lt;= matrix[i][j] &amp;lt;= 1000   代码 自研 class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: i, j = 0, len(matrix) - 1 while i &amp;lt; j: for k in range(i, j): matrix[i][k], matrix[k][j], matrix[j][j-k+i], matrix[j-k+i][i] = matrix[j-k+i], matrix[i][k], matrix[k][j], matrix[j][j-k+i] i += 1 j -= 1 用翻转代替旋转 class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: n = len(matrix) for i in range(n // 2): for j in range(n): matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j] for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 分析  对于行标、列标分别为row、col的元素matrix[row][col]，在旋转变换作用下将映射到matrix[col][n-1-row]。 对于水平翻转结合对称变换，可注意到元素matrix[row][col]先变换为matrix[n-1-row][col]，再变换为matrix[col][n-1-row]。故水平翻转结合对称变换等价于旋转变换。 也可以结合递归思想，由外向内地逐方框进行旋转变换。可以用i、j分别指向方框的最小行标（最小列标）、最大行标（最大列标）。结合下图可实现旋转变换。   </description>
    </item>
    
    <item>
      <title>0009-palindrome number</title>
      <link>https://qidi.ink/post/2021/04/23/0009-palindrome-number/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/23/0009-palindrome-number/</guid>
      <description>问题描述 给定整数x，如果x是一个回文整数，返回true，否则返回false。
 示例1:
 输入: x = 121
输出: true
 示例2:
 输入: x = -121
输出: false
 示例3:
 输入: x = 10
输出: false
 提示: -231 &amp;lt;= x &amp;lt;= 231 - 1
 代码 class Solution: def isPalindrome(self, x: int) -&amp;gt; bool: if x &amp;lt; 0: return False if x % 10 == 0 and x != 0: return False reverse_x = 0 while x &amp;gt; reverse_x: reverse_x = 10 * reverse_x + x % 10 x //= 10 return x == reverse_x or x == reverse_x // 10 参考链接 回文数</description>
    </item>
    
    <item>
      <title>0739-daily temperatures</title>
      <link>https://qidi.ink/post/2021/04/22/739/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/22/739/</guid>
      <description>问题描述 根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，在该位置用0代替。
 示例
 输入: temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
输出: [1, 1, 4, 2, 1, 1, 0, 0]
 提示: 气温列表长度的范围为[1, 30000]。每个气温的值均为华氏度，都是在[30, 100]范围内的整数。
 代码 class Solution: def dailyTemperatures(self, T: List[int]) -&amp;gt; List[int]: monotone_stack, res = list(), [0] * len(T) for i in range(len(T)): if not monotone_stack: monotone_stack.append(i) else: while monotone_stack and T[monotone_stack[-1]] &amp;lt; T[i]: res[monotone_stack[-1]] = i - monotone_stack[-1] monotone_stack.pop() monotone_stack.append(i) return res 分析   维护一个存储下标的单调栈，栈底至栈顶对应的温度依次递减。</description>
    </item>
    
    <item>
      <title>0200-number of islands</title>
      <link>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</guid>
      <description>问题描述 给定一个由1(陆地)和0(水)组成的二维网格，计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，可以假设网格的四条边均被水包围。
 示例1
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;]]
输出: 1
 示例2
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;]]
输出: 3
 提示:
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为0或1   代码 class Solution: def numIslands(self, grid: List[List[str]]) -&amp;gt; int: cnt, self.</description>
    </item>
    
    <item>
      <title>0198-house robber</title>
      <link>https://qidi.ink/post/2021/04/20/0198-house-robber/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/20/0198-house-robber/</guid>
      <description>问题描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。
 示例1:
 输入: [1,2,3,1]
输出: 4
 示例2:
 输入: [2,7,9,3,1]
输出: 12
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 400   代码 class Solution: def rob(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) pre, cur = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): pre, cur = cur, max(cur, pre + nums[i]) return post 分析 本问题可以用动态规划的思想进行求解。</description>
    </item>
    
    <item>
      <title>【动手学深度学习】Ch1.前言</title>
      <link>https://qidi.ink/post/2021/04/20/ch1/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/20/ch1/</guid>
      <description>时至今日，多数计算机程序几乎都是由软件开发人员从零编写的。为了完善业务逻辑，我们需要细致考虑应用程序所有可能 遇到的边界情况，并为这些边界情况设计合适的规则。通过不断测试直至满足需求。
在某些应用场景，我们需要程序自动调整。机器学习是一种可以从经验中学习的技术，通过采用观测数据或与环境交互的形式， 机器学习算法会积累更多的经验，其性能也会逐步提高。
使用机器学习解决问题时，需要精确定义问题，确定输入和输出性质，并选择合适模型。 模型输出由许多参数决定，使用数据集确定当下的最佳参数，这些参数通过某种性能度量 来获取完成任务的最佳性能。使用数据集来选择参数的元程序称为学习算法。学习是一个模型 的训练过程。通过这个过程，我们可以发现正确的参数集。
训练过程通常包含：
 从随机初始化参数的模型开始，这个模型基本毫不智能。 获取一些数据样本。 调整参数，使模型在这些样本中表现更好。 重复第二步和第三步，直至模型表现令人满意。  机器学习这种“通过用数据集来确定程序行为”的方法可看作是“用数据编程”。
关键组件  可以用于学习的数据 用于转换数据的模型 用于量化模型有效性的目标函数 用于调整模型参数以优化目标函数的算法  数据 数据集由一个个样本组成。多数时候，样本遵循独立同分布。
样本也称数据点或数据实例。每个样本由一组称为特征或协变量的属性组成。在监督学习问题中，机器学习模型依据这些属性预测标签。
每个样本的特征具有相同数量的特征。 即：样本特征向量长度固定。特征向量的长度称为数据的维数。
一般而言，更多的数据通常可以训练出更强大的模型，减少对预先设想假设的依赖。大规模为深度学习奠定了成功基础。 某些深度学习模型可以在小数据集上工作，但其效能不比传统方法。
仅仅拥有海量的数据是不够的，还需要正确的数据。当数据不具有充分代表性，甚至包含了一些偏见时，模型很可能会失效。
模型 深度学习关注功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换。
目标函数 机器学习被认为是从经验中学习。学习是指自主提高模型完成某些任务的效能。
需要定义模型优劣程度的度量。这个度量被称为目标函数。因此定义目标函数并将其优化到最低点。 目标函数有时也被称作损失函数。
在回归任务中，常见的损失函数是平方损失，即预测值与实际值之差的平方。
在分类任务重，常见的损失函数是错误率，即预测与实际情况不符的样本比例。
有些目标函数易于被优化，有些目标函数由于不可微性或其他复杂性难以直接优化。此时通常会优化替代目标。
损失函数通常根据模型参数定义，并取决于数据集。在某一数据集上，通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称之为训练集。训练集用于拟合模型参数，测试集用于评估拟合的模型。
优化算法 在获取了数据源及其表示、模型、适合的损失函数之后，需要一种用于搜索最佳参数以最小化损失函数的优化算法。 深度学习中多数优化算法基于梯度下降。
各种机器学习问题 监督学习 监督学习长于在给定输入特征的情况下预测标签。
  回归：当标签取任意数值时，称之为回归问题。
  分类：训练一个分类器，输出为预测的类别。
  标记：学习预测不相互排斥的类别的问题称为多标签分类。
  搜索：在信息检索领域，希望对一组项目进行排序。
  推荐：为特定用户进行个性化推荐。
  序列学习：摄取输入序列或预测输出序列，或两者兼而有之。输入和输出都是可变长度的序列。
  无监督学习 无监督学习是一种数据中不含有”目标“的机器学习问题。</description>
    </item>
    
    <item>
      <title>0031-next permutation</title>
      <link>https://qidi.ink/post/2021/04/19/0031-next-permutation/</link>
      <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/19/0031-next-permutation/</guid>
      <description>问题描述 实现获取下一个排列的函数：将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数组重新排列盛最小的序列（即升序排列）。
考虑原地修改，且只使用额外常数空间。
 示例1
 输入: nums = [1,2,3]
输出: [1,3,2]
 示例2
 输入: nums = [3,2,1]
输出: [1,2,3]
 示例3
 输入: nums = [1,1,5]
输出: [1,5,1]
 示例4
 输入: nums = [1]
输出: [1]
 提示:
 1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 100   代码 pre = post = -1 for pos in range(len(nums) - 1, 0, -1): if nums[pos] &amp;gt; nums[pos - 1]: pre, post = pos - 1, pos break if post == -1: nums.</description>
    </item>
    
    <item>
      <title>【动手学深度学习】数据处理</title>
      <link>https://qidi.ink/post/2021/04/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid>
      <description>目标   深度学习经典模型和最新模型
  机器学习基础
  实践
  深度学习基础
 线性神经网络 多层感知机    卷积神经网络（空间）
  循环神经网络（时间）
  注意力机制
  优化算法
  高性能计算
  计算机视觉
  自然语言处理
  将要学习到什么  深度学习里有什么技术 如何实现和调参 背后的原因（直觉、数学）  资源  教材:https://zh-v2.d2l.ai/  Q&amp;amp;A  模型可解释性  有效与可解释性不同。    安装 </description>
    </item>
    
    <item>
      <title>0022-generate parentheses</title>
      <link>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</guid>
      <description>问题描述 设计函数，生成所有可能的并且有效的括号组合。
数字n代表生成括号的对数。
 示例1:
 输入: n = 3
输出: [&amp;quot;((()))&amp;quot;, &amp;ldquo;(()())&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, &amp;ldquo;()(())&amp;rdquo;, &amp;ldquo;()()()&amp;quot;]
 示例2:
 输入: n = 1
输出: [&amp;quot;()&amp;quot;]
 提示: 1 &amp;lt;= n &amp;lt;= 8
 代码 DFS1 class Solution: def helper(self, comb = &amp;#39;&amp;#39;, lcnt = 0, matched = 0) -&amp;gt; None: if matched == self.n: self.res.append(comb) elif matched == lcnt: self.helper(comb + &amp;#39;(&amp;#39;, lcnt + 1, matched) elif lcnt &amp;lt; self.n: self.</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch5. Pandas基础</title>
      <link>https://qidi.ink/post/2021/04/18/python-ch5-pandas/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/18/python-ch5-pandas/</guid>
      <description>Pandas 简介  Pandas采用了Numpy编码风格。特别是基于数组的函数和不使用for循环的数据处理。  Numpy更适合处理统一的数值数组数据。 Pandas专门为处理表格和混杂数据设计。    Pandas 数据结构 Series  Series是一种类似于一维数组的对象。由一组数据以及一组与之相关的数据标签（索引）组成。  可通过Series的values和index属性获取其数组表示形式和索引对象。 可通过指定index关键字制定索引。  obj = pd.Series([4, 7, -4, 3], index = [&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])     由于可看作是索引值到数据值的一个映射，Series可以看成是一种定长的有序字典。  可以通过Python内置字典来创建Series。  如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。可以传入排序好的字典的键来改变顺序。      sdata = {&amp;#39;Ohio&amp;#39;: 35000, &amp;#39;Texas&amp;#39;: 71000, &amp;#39;Oregon&amp;#39;: 16000, &amp;#39;Utah&amp;#39;: 5000} states = [&amp;#39;California&amp;#39;, &amp;#39;Ohio&amp;#39;, &amp;#39;Oregon&amp;#39;, &amp;#39;Texas&amp;#39;] obj = pd.Series(sdata, index = states) # obj: # California NaN # Ohio 35000.</description>
    </item>
    
    <item>
      <title>0017-letter combinations of a phone number</title>
      <link>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</guid>
      <description>题目描述 给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。
给定数字到字母的映射如下（与电话按键相同）。
 示例1
 输入: digits = &amp;ldquo;23&amp;rdquo;
输出: [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;]
 示例2
 输入: digits = &amp;quot;&amp;quot;
输出: []
 示例3
 输入: digits = &amp;ldquo;2&amp;rdquo;
输出: [&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;]
 提示:
 0 &amp;lt;= digits.length &amp;lt;= 4 digits[i]是范围[&#39;2&#39;, &#39;9&#39;]的一个数字 答案可以按任意顺序返回   代码 BFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: digit = [str(x) for x in range(2, 10)] alphabet = [&amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] d = dict(zip(digit, alphabet)) queue = list() cnt = 0 for digit in digits: if not cnt: for alphabet in d[digit]: queue.</description>
    </item>
    
    <item>
      <title>0019-remove nth node from end of list</title>
      <link>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</guid>
      <description>删除链表的倒数第N个结点 给定一个链表，删除链表的倒数第n个结点，并返回链表的头结点。
 示例1
 输入: head = [1,2,3,4,5], n = 2
输出: [1,2,3,5]
 示例2
 输入: head = [1], n = 1
输出: []
 示例3
 输入: head = [1,2], n = 1
输出: [1]
 提示:
 链表中节点的数目为sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch4. Numpy基础 数组和矢量计算</title>
      <link>https://qidi.ink/post/2021/04/17/python-ch4-numpy/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/python-ch4-numpy/</guid>
      <description>ndarray: 一种多维数组对象  ndarray是一个通用的同构数据多维容器。  ndarray中所有元素必须是相同类型的。 ndarray有shape属性（表示各维度大小的元组）和dtype属性（用于说明数组数据类型的对象）    创建ndarray  array函数：将一切序列对象（含其他数组）转化为NumPy数组。 np.zeros、np.ones、np.empty分别可以创建指定长度或形状的全0或全1数组或没有任何具体值的数组。需传入一个表示形状的元组  np.empty返回数组的元素大多是未初始化的值，非全0或全1。   np.arange函数是Python内置函数range的数组版。     函数 说明     array 将输入数据（列表、元组、数组或序列类型）转换为ndarray。推断或指定dtype。创建新ndarray对象   asarray 将输入转换为ndarray，如果输入本身是ndarray对象则指向输入   arange 与内置range相似，返回ndarray对象而非列表`   ones 根据指定的形状和dtype创建一个全1数组   ones_like 以另一个数组为参数，根据其形状和dtype创建一个全1数组   zeros 根据指定的形状和dtype创建一个全0数组   zeros_like 以另一个数组为参数，根据其形状和dtype创建一个全0数组   empty 根据指定的形状和dtype创建数组，只分配内存空间不填充值   empty_like 以另一个数组为参数，根据祺形状和dtype创建数组，只分配内存空间不填充值   full 根据指定的形状和dtype创建数组，值依据参数fill_value指定   full_like 以另一个数组为参数，根据祺形状和dtype创建数组，值依据参数fill_value指定   eye 创建N阶方阵    ndarray数据类型  dtype含有ndarray将一块内存解释为特定数据类型所需的信息。  需要控制数据再内存和磁盘中的存储方式时，要了解如何控制存储类型。 narray的astype方法将数组的dtype转变后返回。当前数组不变。即创建一个新的数组。    NumPy数组运算  数组使得批量处理数据不需要借助循环。即向量化(vectorization)。  相同shape的数组之间的算术运算将作用于元素级。 数组与标量的算术运算会将标量值传播到数组各个元素。 大小相同的数组之间的比较会生成布尔值数组。  大小不同的数组之间的运算称为广播。      索引和切片  将一个标量值赋给一个切片时，该值会自动传播。  arr = np.</description>
    </item>
    
    <item>
      <title>0015-3sum</title>
      <link>https://qidi.ink/post/2021/04/16/0015-3sum/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/16/0015-3sum/</guid>
      <description>问题描述 给定包含n个整数的数组nums。
判断nums中是否存在三个元素a, b, c，使得a + b + c = 0？
找出所有和为0且不重复的三元组。
 示例1
 输入: nums = [-1, 0, 1, 2, -1, -4]
输出: [[-1, -1, 2], [-1, 0, 1]]
 示例2
 输入: nums = []
输出: []
 示例3
 输入: nums = [0]
输出: []
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  注意: 答案中不包含重复的三元组。
 代码 class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] if not nums or len(nums) &amp;lt;= 2: return res nums.</description>
    </item>
    
    <item>
      <title>0011-container with most water</title>
      <link>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</guid>
      <description>问题描述 给定n个非负整数a1,a2,...,an。每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。
 示例1
 输入: [1,8,6,2,5,4,8,3,7]
输出: 49
 示例2
 输入: [1,1]
输出: 1
 示例3
 输入: [4,3,2,1,4]
输出: 16
 示例4
 输入: [1,2,1]
输出: 2
 提示:
 n = height.length 2 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 3 * 104   代码 class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: l, r, res = 0, len(height) - 1, 0 while l &amp;lt; r: res = max(res, (r - l) * min(height[r], height[l])) if height[l] &amp;lt; height[r]: l += 1 elif height[l] &amp;gt; height[r]: r -= 1 else: l, r = l + 1, r - 1 return res 分析   使用双指针法搜索盛最多水时的容器边界。搜索过程中进行剪枝。</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch3. Python数据结构 函数和文件</title>
      <link>https://qidi.ink/post/2021/04/15/python-ch2-python/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/python-ch2-python/</guid>
      <description>数据结构和序列 元组  元组是一个固定长度的不可变Python序列对象。 创建元组，可用逗号分隔一列值。  In [1]: tup = 4, 5, 6  In [2]: tup Out[2]: (4, 5, 6)     用复杂的表达式定义元组，最好将值放到圆括号内。  In [3]: nested_tup = (4, 5, 6), (7, 8)  In [4]: nested_tup Out[4]: ((4, 5, 6), (7, 8))     元组是不可变对象。但元组中存储的对象可以是可变对象。  可以原地修改这些可变对象。   将元组赋值给类似元组的变量的语句，会拆分等号右边的值。  In [5]: tup = 4, 5, (6, 7)  In [6]: a, b, (c, d) = tup  In [7]: d Out[7]: 7       变量拆分常用于迭代元组或列表:  In [8]: seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]  In[9] : for a, b, c in seq: &amp;hellip;     使用*_的元组拆分:  In [10]: values = 1, 2, 3, 4, 5  In [11]: a, b, *_ = values  In [12]: _ Out[12]: [3, 4, 5]        列表   切片语法seq[::-1]返回颠倒的列表或元组。</description>
    </item>
    
    <item>
      <title>Shell Shortcuts</title>
      <link>https://qidi.ink/post/2021/04/15/shell-shortcuts/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/shell-shortcuts/</guid>
      <description>   快捷键 说明     Ctrl-P 用当前输入的文本搜索之前的命令   Ctrl-N 用当前输入的文本搜索之后的命令   Ctrl-Shift-V 从剪贴板粘贴文本   Ctrl-C 中断运行的代码   Ctrl-A 将光标移动到当前行的开头   Ctrl-E 将光标移动到当前行的末尾   Ctrl-K 删除光标到行末的文本   Ctrl-U 删除当前行的所有文本   Ctrl-F 光标向行末移动一个字符   Ctrl-B 光标向行首移动一个字符   Ctrl-L 清空屏幕    </description>
    </item>
    
    <item>
      <title>0005-longest palindromic substring</title>
      <link>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</guid>
      <description>最长回文子串 给定字符串s，找到s中的最长回文子串。
 示例1：
 输入: s = &amp;ldquo;babad&amp;rdquo;
输出: &amp;ldquo;bab&amp;quot;或&amp;quot;aba&amp;rdquo;
 示例2：
 输入: s = &amp;ldquo;cbbd&amp;rdquo;
输出: &amp;ldquo;bb&amp;rdquo;
 示例3：
 输入: s = &amp;ldquo;a&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 示例4：
 输入: s = &amp;ldquo;ac&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 提示:
 1 &amp;lt;= s.length &amp;lt;= 1000 s仅由数字和英文字母（大写和/或小写）组成   代码 动态规划法 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) # 记录dp过程中发现的最长回文子串 start, stride = 0, 0 # step = 0, 默认为True dp = [[True for j in range(n)] for i in range(n)] # step = 1, 另一种构建块，进行判定 for in in range(n - 1): if s[i] == s[i+1]: start, stride = i, 1 else: dp[i][i+1] = False # step in [2, n-1], 进行判定 for step in range(2, n): for i in range(n - step): if not dp[i + 1][i + step - 1] or s[i] !</description>
    </item>
    
    <item>
      <title>0226-invert-binary-tree</title>
      <link>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</guid>
      <description>题目描述 翻转一棵二叉树。
 示例
 输入:
 4 / \ 2 7 / \ / \ 1 3 6 9  输出:
 4 / \ 7 2 / \ / \ 9 6 3 1    代码 递归 # Definition for a binary tree node # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.</description>
    </item>
    
    <item>
      <title>0234-palindrome linked list</title>
      <link>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</guid>
      <description>问题描述 请判断一个链表是否为回文链表
 示例1:
 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出: true
 示例2:
 输入: 1-&amp;gt;2
输出: false
 提示:考虑使用O(n)时间复杂度和O(1)空间复杂度。
 代码 将链表中的元素复制到数组中，借助数组元素的随机访问特性，使用双指针法判定是否为回文链表 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.val = val # self.next = next class Solution(self, head : ListNode) -&amp;gt; bool: ptr, array = head, list() while ptr: array.append(ptr.val) ptr = ptr.next lptr, rptr = 0, len(array) - 1 while lptr &amp;lt; rptr: if array[lptr] !</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch2. Python语法基础 Ipython和Jupyter Notebooks</title>
      <link>https://qidi.ink/post/2021/04/13/python-ch2-python-ipython-jupyter-notebooks/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/python-ch2-python-ipython-jupyter-notebooks/</guid>
      <description>2.1 Python解释器  退出Python解释器返回终端，可输入exit()或Ctrl+D。  2.2 Ipython基础   在IPython中使用%run命令，将执行指定文件，执行结束之后可以与结果进行交互
 如果是在%run一个脚本或一条语句时抛出异常，Ipython默认会打印完整的调用栈，在栈的每个点都会有几行上下文。在发生错误之后，可以使用%debug或%pdb访问栈进行事后调试。    Ipython shell相对于标准Python解释器的进步之一是具备其他IDE和交互计算分析环境所具有的Tab补全功能
  对象的自省:在变量前后使用问号?，可以显示对象的信息。
 对于函数或实例方法，将显示文档字符串。 使用??将会显示函数源码。add_numbers??    在Jupyter notebook中，可以使用%load，将脚本导入到一个代码格中。
  代码运行时按下Ctrl-C，无论是%run或长时间运行命令，都会导致KeyboardInterrupt。这会使几乎所有Pyhton程序立即停止。
  从剪贴板执行程序:如果使用Jupyter notebook，可以将代码复制粘贴到任意代码格执行。在Ipython shell中也可以从剪切板执行。
 %paste可以直接运行剪贴板中的代码。 %cpaste可以粘贴任意多的代码再运行。可以在运行之前查看代码。如果粘贴了错误的代码，可以使用Ctrl-C中断。    IPython有众多键盘快捷键(类似Unix bash Shell)和交互shell的历史命令。
  Jupyter notebook有另一套庞大的快捷键，可参阅Jupyter notebook的帮助文档。
  魔术命令：指令前添加%前缀
 如可以用%timeit%测量Python语句的执行时间。 某些魔术命令有命令行选项，可通过?查看。debug?    2.3 Python语法基础   Python语言设计强调可读性。Python有时被称为可执行的伪代码
  对象作为参数传递给被调函数时，后者的局部变量引用对象，故可以改变可变参数的内容。
  Python变量不固定类型，可引用任意类型对象，此为动态引用。</description>
    </item>
    
    <item>
      <title>Google Chrome Shortcuts</title>
      <link>https://qidi.ink/post/2021/04/13/google-chrome-shortcuts/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/google-chrome-shortcuts/</guid>
      <description>cmd + shift + T: 打开上一个关闭的标签页</description>
    </item>
    
    <item>
      <title>0461-hamming distance</title>
      <link>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</guid>
      <description>问题描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数x和y，计算它们之间的汉明距离。
 示例
 输入: x = 1, y = 4
输出: 2
解释:
1 (0 0 0 1)
4 (0 1 0 0)
 注意: 0 &amp;lt;= x, y &amp;lt; 231
 代码 Brian W. Kernighan &amp;amp; Dennis M. Ritchie class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: cnt += 1 xor &amp;amp;= xor - 1 return cnt Circular shift class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: if xor &amp;amp; 1: cnt += 1 return cnt 分析 本问题体现了位运算中关于计1的技巧。</description>
    </item>
    
    <item>
      <title>0543-diameter of binary tree</title>
      <link>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</guid>
      <description>问题描述 给定一棵二叉树，计算它的直径长度。一棵二叉树的直径长度是指任意两个节点路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。
 示例
 输入:
 1 / \ 2 3 / \ 4 5  输出: 3
解释: 路径为[4,2,1,3]或[5,2,1,3]。
 注意:两节点之间的路径长度是以它们之间边的数目表示。
 代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.right = right class Solution: def calDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: left_depth, right_depth = self.</description>
    </item>
    
    <item>
      <title>0617-merge two binary trees</title>
      <link>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</guid>
      <description>问题描述 给定两个二叉树，想想当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL的节点将直接作为新二叉树的节点。
 示例
 输入:
 Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7  输出:
 3 / \ 4 5 / \ \ 5 4 7   注意:合并必须从两个树的根节点开始。
 代码 DFS算法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.</description>
    </item>
    
    <item>
      <title>0155-min stack</title>
      <link>https://qidi.ink/post/2021/04/11/0155-min-stack/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0155-min-stack/</guid>
      <description>题目描述 设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。
 push(x): 将元素x推入栈中 pop(): 删除栈顶的元素 top(): 获取栈顶元素 getMin(): 检索栈中的最小元素   示例
 输入:
[&amp;ldquo;MinStack&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;,&amp;ldquo;pop&amp;rdquo;,&amp;ldquo;top&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;]
[[],[-2],[0],[-3],[],[],[],[]]
输出:
[null,null,null,null,-3,null,0,-2]
解释:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -3.
minStack.pop();
minStack.top(); &amp;ndash;&amp;gt; 返回 0.
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -2.
 提示
 pop、top和getMin操作总是在非空栈上调用。   代码 class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here. &amp;#34;&amp;#34;&amp;#34; self.Minstack = [] def push(self, val: int) -&amp;gt; None: if not self.</description>
    </item>
    
    <item>
      <title>0206-reverse linked list</title>
      <link>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</guid>
      <description>问题描述 反转一个简单链表。
 示例:
 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
 提示:
 可以使用递归和迭代两种方式反转链表。
  代码 递归 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head rhead = self.reverseList(head.next) head.next.next, head.next = head, None return rhead 迭代 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.</description>
    </item>
    
    <item>
      <title>0283-move zeroes</title>
      <link>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</guid>
      <description>问题描述 给定数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。
 示例
 输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
 说明:
   必须在原数组上操作，不能拷贝额外的数组
  尽量减少操作次数
    代码 双指针 - 1 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: count = 0 for num in nums: if num: nums[count] = num count += 1 nums[count:] = [0] * len(nums[count:]) 双指针 - 2 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: i = 0 for j in range(len(nums)): if nums[j]: nums[i], nums[j] = nums[j], nums[i] i += 1 注: 在每一次循环之前，i左边的元素均非零。</description>
    </item>
    
    <item>
      <title>0448-find all numbers disappeared in an array</title>
      <link>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>找到所有数组中消失的数字 给定一个范围在 1 &amp;lt;= a[i] &amp;lt;= n(n = 数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在[1,n]范围之间没有出现在数组中的数字。
考虑不使用额外空间的时间复杂度为O(n)的算法。
 示例
 输入: [4,3,2,7,8,2,3,1]
输出: [5,6]
  代码 O(1)空间复杂度 class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: nums[(num-1) % n] += n for i, num in enumerate(nums): if num &amp;lt;= n: res.append(i+1) return res class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: if nums[abs(num)-1] &amp;gt; 0: nums[abs(num)-1] *= -1 for i, num in enumerate(nums): if num &amp;gt; 0: res.</description>
    </item>
    
    <item>
      <title>《当我真正开始爱自己》</title>
      <link>https://qidi.ink/post/2021/04/11/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1/</guid>
      <description>当我真正开始爱自己，
我才认识到，所有的痛苦和情感的折磨，
都只是提醒我：活着，不要违背自己的本心。
今天我明白了，这叫做 「真实」
 当我真正开始爱自己，
我才懂得，把自己的愿望强加于人，
是多么的无礼，就算我知道，时机并不成熟，
那人也还没有做好准备，
就算那个人就是我自己，
今天我明白了，这叫做 「尊重」
 当我真正开始爱自己，
我不再渴求不同的人生，
我知道任何发生在我身边的事情，
都是对我成长的邀请。
如今，我称之为 「成熟」
 当我真正开始爱自己，
我才明白，我其实一直都在正确的时间，
正确的地方，发生的一切都恰如其分。
由此我得以平静。
今天我明白了，这叫做 「自信」
 当我真正开始爱自己，
我不再牺牲自己的自由时间，
不再去勾画什么宏伟的明天。
今天我只做有趣和快乐的事，
做自己热爱，让心欢喜的事，
用我的方式，以我的韵律。
今天我明白了，这叫做 「单纯」
 当我真正开始爱自己，
我开始远离一切不健康的东西。
不论是饮食和人物，还是事情和环境，
我远离一切让我远离本真的东西。
从前我把这叫做“追求健康的自私自利”，
但今天我明白了，这是 「自爱」
 当我真正开始爱自己，
我不再总想着要永远正确，
不犯错误。
今天我明白了，这叫做 「谦逊」
 当我真正开始爱自己，
我不再继续沉溺于过去，
也不再为明天而忧虑，
现在我只活在一切正在发生的当下，
今天，我活在此时此地，
如此日复一日。这就叫 「完美」
 当我真正开始爱自己，
我明白，我的思虑让我变得贫乏和病态，
但当我唤起了心灵的力量，
理智就变成了一个重要的伙伴，
这种组合我称之为 「心的智慧」
 我们无须再害怕自己和别人的分歧，
矛盾和问题，
因为即使星星有时也会碰在一起，
形成新的世界，</description>
    </item>
    
    <item>
      <title>0160-intersection of two linked lists</title>
      <link>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</guid>
      <description>题目描述 编写一个程序，找到两个单链表相交的起始节点。
 示例1:
 输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出: Reference of the node with value = 8
输入解释: 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。链表A为[4,1,8,4,5]，链表B为[5,0,1,8,4,5]。在A中，相交节点前有2个节点；在B中，相交节点前有3个节点。
 示例2:
 输入: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Refernce of the node with value = 2
输入解释: 相交节点的值为 2 （注意，如果两个链表相交则不能为0）。链表A为[0,9,1,2,4]，链表B为[3,2,4]。在A中，相交节点前有3个节点；在B中，相交节点前有1个节点。
 示例3:
 输入: intersecVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</description>
    </item>
    
    <item>
      <title>0169-majority element</title>
      <link>https://qidi.ink/post/2021/04/10/0169-majority-element/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0169-majority-element/</guid>
      <description>多数元素 给定一个大小为n的数组，找到其中的多数元素。
多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。
可以假设数组是非空的，并且给定的数组总是存在多数元素。
 尝试使用时间复杂度为O(n)，空间复杂度为O(1)的算法解决此问题。   示例1
 输入: [3,2,3]
输出: 3
 示例2
 输入: [2,2,1,1,1,2,2]
输出: 2
  代码 Boyer-Moore 投票法 class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: winner, winner_counter = None, 0 for candidate in nums: if winner_counter == 0: winner = candidate winner_counter += 1 elif winner == candidate: winner_counter += 1 else: winner_counter -= 1 return winner 分析 Boyer-Moore 投票法 Moore投票法旨在解决：如何在任意多的候选人中，定出获得票数最多的候选人。</description>
    </item>
    
    <item>
      <title>0101-symmetric tree</title>
      <link>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</guid>
      <description>题目描述 给定一个二叉树，检查它是否是镜像对称的。
 示例1:
 输入:
 1 / \ 2 2 / \ / \ 3 4 4 3  输出: True
 示例2:
 输入:
 1 / \ 2 2 \ \ 3 3    代码: # 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSame(self, lptr:TreeNode, rptr:TreeNode) -&amp;gt; bool: if not lptr and not rptr: return True if not lptr or not rptr or lptr.</description>
    </item>
    
    <item>
      <title>0104-maximum depth of binary tree</title>
      <link>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根结点到最远叶子结点的最长路径上的节点数。
 示例:
给定二叉树[3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7  返回它的最大深度3。
说明: 叶子结点是指没有子节点的节点。
 代码 # 递归，深度优先遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: return 1 + max(self.maxDepth(root.left), self.</description>
    </item>
    
    <item>
      <title>0121-best time to buy and sell stock</title>
      <link>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</guid>
      <description>问题描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。
代码: class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = [0] * len(prices) for i in range(1, len(prices)): profit[i] = max(0, profit[i-1] + prices[i] - prices[i-1]) return max(profit) 分析:  本问题与最大子序和问题相似  </description>
    </item>
    
    <item>
      <title>0136-single nubmer</title>
      <link>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</guid>
      <description>问题描述  给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
示例1:
 输入: [2,2,1]
输出: 1
 示例2:
 输入: [4,1,2,1,2]
输出: 4
 说明:
考虑线性时间复杂度的原地算法。
 代码 # 异或运算 class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: return reduce(lambda x,y: x^y, nums) 分析 map/reduce:  map()函数接收两个参数，一为函数，一为Iterable。  map()将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。   reduce()函数接收两个参数，一为函数，一为序列。效果为：  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)    示例1:
 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小些的规范名字。
输入[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。
 list(map(lambda x: x.</description>
    </item>
    
    <item>
      <title>0141-linked list cycle</title>
      <link>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</guid>
      <description>问题描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回true。否则返回false。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: false
解释: 链表中没有环。
 提示:
 链表中节点的数目范围是[0, 104] -105 &amp;lt;= Node.val &amp;lt;= 105 pos 为 -1或者链表中的一个有效索引。   代码 # hashTable # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Git 简介</title>
      <link>https://qidi.ink/post/2021/04/09/git/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/git/</guid>
      <description>版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本。版本控制系统可以帮助将选定的文件甚或整个项目回溯到之前某个状态、比较文件的变化细节、查看何时报告了某个功能缺陷。
分布式版本控制系统 在分布式版本控制系统 (Distributed Version Control System) 中，客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。
每一次的克隆操作，实际上都是一次对代码仓库的完整备份。
任何一处协同工作的服务器发生故障，都可以用任何一个镜像出来的本地仓库恢复。
Git 简史 Git诞生于一个极富纷争的年代。
Linux内核开源项目有着为数众多的参与者。1991-2002年间，Linux内核维护工作牵涉到大量提交补丁、保存归档的繁琐事务。2002年，项目组启用分布式版本控制系统BitKeeper来管理和维护代码。2005年，BitKeeper的开发者同Linux内核开源社区合作关系结束，迫使Linux开源社区（特别是Linux的缔造者Linus Torvalds）开发出自己的版本控制系统。他们对新的系统制定了若干目标：
  速度
  简单的设计
  对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
  完全分布式
  有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）
  自2005年诞生以来，Git日臻完善。在高度易用的同时，保留着初期设定的目标。Git速度飞快，及其适合管理大型项目，有着令人难以置信的非线性分支管理系统。
Git 是什么 Git与其他的版本控制系统有颇多相似之处，但在对信息的存储和认知方式上有着很大差异。
直接记录快照，而非差异比较 大部分系统以文件变更列表的方式存储信息，这类系统(常称为基于差异(delta-based)的版本控制)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异。 Git对待数据更像是一个快照流。每当提交更新或保存项目状态时，Git对此时全部文件创建快照并保存快照索引。 近乎所有操作都是本地执行 在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。
Git保证完整性 Git中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着在Git不知情时不能更改任何文件内容或目录内容。
Git用于计算校验和的机制为SHA-1散列，这是一个由40个十六进制字符组成的字符串，基于Git中文件的内容或目录结构计算出来。
Git中众多场景应用这种哈希值。Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
Git一般只添加数据 Git操作几乎只向Git数据库中添加数据。而Git几乎不会执行任何可能导致文件不可恢复的操作，即Git不会从数据库中删除数据。
三种状态 Git有三种状态，文件状态可能处于其中之一：
已修改(modified):修改了文件，但还没保存到数据库中。
已暂存(staged):对一个已修改文件的当前版本做了标记，使其包含在下次提交的快照中。
已提交(committed):数据已经安全地保存在本地数据库中。
相应地，在Git中有三个阶段：工作区、暂存区、Git目录。 工作区:对项目的某个版本独立提取出的内容。
暂存区:保存了下次将要提交的文件信息列表信息。
Git目录:Git用来保存项目的元数据和对象数据库的地方。
基本的Git工作流程如下:
1.在工作区中修改文件。
2.将下次要提交的更改选择性地暂存。
3.提交更新，找到暂存区的文件，将快照永久性地存储到Git目录中。
HELP 使用Git时若需要获取帮助，有三种查阅手册的等价方式：
$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help</description>
    </item>
    
    <item>
      <title>0021-merge two sorted list</title>
      <link>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</guid>
      <description>题目描述  将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例1
 输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
 示例2
 输入: l1 = [], l2 = []
输出: []
 示例3
 输入: l1 = [], l2 = [0]
输出: [0]
 提示:
 两个链表的节点数目范围是[0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按非递减顺序排列   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>0053-maximum subarray</title>
      <link>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</guid>
      <description>题目描述  给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例1:
 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
 示例2:
 输入: nums = [1]
输出: 1
 示例3:
 输入: nums = [0]
输出: 0
 示例4:
 输入: nums = [-1]
输出: -1
 示例5:
 输入: nums = [-100000]
输出: -100000
 提示:
  1 &amp;lt;= nums.length &amp;lt;= 3 * 104
  -105 &amp;lt;= nums[i] &amp;lt;= 105
   代码 class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i-1] + nums[i]) return max(nums) 分析   考虑nums[i]，若nums[i-1]所存储的累加值为正，则对nums[i]有增益。从而以i结尾的子序和大于nums[i]。</description>
    </item>
    
    <item>
      <title>0070-climbing stairs</title>
      <link>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</guid>
      <description>问题描述
假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例1:
 输入: 2
输出: 2
解释: 有两种方法可以到达楼顶。
  1阶 + 1阶
  2阶
   示例2:
 输入: 3
输出: 3
解释:
  1阶 + 1阶 + 1阶
  1阶 + 2阶
  2阶 + 1阶
   注意:
给定n是一个正整数。
 代码 # 递归，超时 class Solution: def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt;= 2: return n else: return self.</description>
    </item>
    
    <item>
      <title>0002-add-two-numbers</title>
      <link>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</guid>
      <description>题目描述  给定两个非空的链表，表示两个非负整数。它们的每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。
请你将两个数字相加，并以相同形式返回一个表示和的链表
你可以假设除了数字0之外，这两个数都不会以0开头。
示例1
 输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
 示例2
 输入: l1 = [0], l2 = [0]
输出: [0]
 示例3
 输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
 提示
  每个链表中的节点数在范围[1, 100]内
  0 &amp;lt;= Node.val &amp;lt;= 9
  题目数据保证列表表示的数字不含前导零
   代码 # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>0003-longest substring without repeating characters</title>
      <link>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</guid>
      <description>题目描述  给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
示例1
 输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;abc&amp;quot;，所以其长度为3。
 示例2
 输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是&amp;quot;b&amp;quot;，所以其长度为1。
 示例3
 输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;wke&amp;quot;，所以其长度为3。
 示例4
 输入: s = &amp;quot;&amp;quot;
输出: 0
 提示
  0 &amp;lt;= s.length &amp;lt;= 5 * 104
  s由英文字母、数字、符号和空格组成
   代码 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: #考虑以某一下标为起始位置的最长子串。 l = r = maxlen = 0 hashtable = dict() #记录某一元素出现的最靠结尾的下标 while r in range(len(s)): if s[r] in hashtable and hashtable[s[r]] in range(l, r): l = hashtable[s[r]] + 1 hashtable[s[r]] = r maxlen = max(maxlen, r - l + 1) r += 1 return maxlen 分析  使用滑动窗方法处理子字符串  </description>
    </item>
    
    <item>
      <title>0020-Valid Parentheses</title>
      <link>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</guid>
      <description>问题描述  给定一个只包括&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;,&#39;]&#39;的字符串s，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  示例1:
 输入: s = &amp;ldquo;()&amp;rdquo;
输出: true
 示例2:
 输入: s = &amp;ldquo;()[]{}&amp;rdquo;
输出: true
 示例3:
 输入: s = &amp;ldquo;(]&amp;rdquo;
输出: false
 示例4:
 输入: s = &amp;ldquo;([)]&amp;rdquo;
输出: false
 示例5:
 输入: s = &amp;ldquo;{[]}&amp;rdquo;
输出:true
 提示:
  1 &amp;lt;= s.length &amp;lt;= 104
  s仅由括号()[]{}组成
   代码 class Solution: def isValid(self, s: str) -&amp;gt; bool: if len(s) % 2 == 1: return False dictionary = {&amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;} stack = [] for ch in s: if ch in dictionary: stack.</description>
    </item>
    
    <item>
      <title>0001-Two Sum</title>
      <link>https://qidi.ink/post/2021/04/06/0001-two-sum/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/0001-two-sum/</guid>
      <description>题目描述  给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例1
 输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]。
 示例2
 输入: nums = [3,2,4], target = 6
输出: [1,2]
 示例3
 输入: nums = [3,3], target = 6
输出: [0,1]
 提示
  2 &amp;lt;= nums.length &amp;lt;= 103
  只会存在一个有效答案
   代码 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashtable = dict() for i, val in enumerate(nums): if target - val in hashtable: return [hashtable[target - val], i] else: hashtable[val] = i 分析  使用哈希将查找元素的时间复杂度降至O(1)  </description>
    </item>
    
    <item>
      <title>Markdown Grammer</title>
      <link>https://qidi.ink/post/2021/04/06/markdown-grammer/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/markdown-grammer/</guid>
      <description>HTML 上标: Bull&amp;lt;sup&amp;gt;TM&amp;lt;/sup&amp;gt; BullTM
下标: H&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;O H2O
表格 markdown制作表格，使用|分隔不同单元格，-分隔表头和其他行。
语法格式为：
 | 表头 | 表头 |
| ---- | ---- |
| 单元 | 单元 |
| 单元 | 单元 |
 可以设置表格的对齐方式：
 -:设置单元格内容和标题栏居右对齐 :-设置单元格内容和标题栏居左对齐 :-:设置单元格内容和标题栏居中对齐  </description>
    </item>
    
    <item>
      <title>VIM Shorcuts</title>
      <link>https://qidi.ink/post/2021/04/06/vim-shorcuts/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/vim-shorcuts/</guid>
      <description>跳转命令 shift + g: 跳转到文件结尾
gg: 跳转到文件开头
:10: 跳转到第10行
删除命令 :1,10d: VIM模式下删除1～10行的内容
选中命令 v+j/k/h/l: 进入VISUAL模式，文本选中。
对于选中的文本可执行以下操作：
d: 剪切
y: 复制
p: 粘贴
0: 选中当前行，光标位置到行首
$: 选中当前行，光标位置到行尾
撤销与恢复 u: 撤销上一次操作
:redo: 恢复</description>
    </item>
    
    <item>
      <title>基于Hugo和Github Pages的个人博客搭建过程</title>
      <link>https://qidi.ink/post/2021/04/06/hugo-github-pages/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/hugo-github-pages/</guid>
      <description>撰写博文 使用RStudio IDE
blogdown::serve_site()命令，提供个人网站的本地实时渲染
blogdown::hugo_build()命令，在push给Github远程仓库之前，编译文件
可以在Vim中使用markdown语法对文本进行编辑</description>
    </item>
    
    <item>
      <title>用Parallels Desktop搭建Ubuntu 20.04虚拟机</title>
      <link>https://qidi.ink/post/2021/04/06/macos-vmware-ubuntu/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/macos-vmware-ubuntu/</guid>
      <description>配置虚拟机使用宿主机VPN 环境介绍 - macOS Big Sur: 11.0.1 - ShadowsocksX-NG: 1.4.1-R8 - Parallels Desktop: 16.5.0 - Ubuntu: 20.04 配置过程  修改ShadowsocksX-NG http 代理端口  HTTP Proxy Preferences中：
 设置HTTP Proxy Listen Address为0.0.0.0 设置HTTP Proxy Listen Port为1087  测试通过局域网是否能访问(可选)   通过lsof查看是否能够在0.0.0.0:1087端口工作。  $ lsof -sTCP:LISTEN -n -P|grep 1087 若显示*:1087说明服务正常。
查看虚拟机局域网ip  在虚拟机中使用ifconfig命令查看局域网ip(以192、172、10开头)并记录。
找到主机的局域网ip  在主机上找出与虚拟机同网段的ip地址，记为IP。此ip地址和虚拟机ip地址的前三段相同。
虚拟机export代理配置  在.bashrc、.zshrc、.profile文件中，指定代理地址。
export http_proxy=http://IP:1087 export https_proxy=http://IP:1087 修改虚拟机中的Settings  打开Settings-Network-VPN-Network Proxy-Manual。
设置HTTP Proxy和HTTPS Proxy中的地址和端口分别为IP和1087。
参考链接 Mac下虚拟机如何使用主机的shadowsockets科学上网</description>
    </item>
    
  </channel>
</rss>
