<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>日拱一卒 功不唐捐 on XIU</title>
    <link>https://qidi.ink/</link>
    <description>Recent content in 日拱一卒 功不唐捐 on XIU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://qidi.ink/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0240-search a 2d matrix ii</title>
      <link>https://qidi.ink/post/2021/05/15/0240-search-a-2d-matrix-ii/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/15/0240-search-a-2d-matrix-ii/</guid>
      <description>问题描述 在m x n矩阵matrix中搜索目标值target，该矩阵具有以下特性： - 每行的元素从左到右升序排列。 - 每列的元素从上到下升序排列。
 示例1:
 输入: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出: true
 示例2:
 输入: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出: false
 提示:
 m == matrix.length n == matrix[i].length 1 &amp;lt;= n, m &amp;lt;= 300 -109 &amp;lt;= matrix[i][j] &amp;lt;= 109 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 -109 &amp;lt;= target &amp;lt;= 109   代码 class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&amp;gt; bool: m, n = len(matrix), len(matrix[0]) i, j = 0, n-1 while i in range(m) and j in range(n): if matrix[i][j] == target: return True if matrix[i][j] &amp;lt; target: i += 1 else: j -= 1 return False 参考链接 详细通俗的思路分析，多解法</description>
    </item>
    
    <item>
      <title>0096-unique binary search trees</title>
      <link>https://qidi.ink/post/2021/05/14/96/</link>
      <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/14/96/</guid>
      <description>问题描述 给定整数n，求恰由n个节点组成且节点值从1到n互不相同的二叉搜索树的个数。
 示例1:
 输入: n = 3
输出: 5
 示例2:
 输入: n = 1
输出: 1
 提示: 1 &amp;lt;= n &amp;lt;= 19
 代码 class Solution: def numTrees(self, n: int) -&amp;gt; int: dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for amount in range(2, n+1): for root in range(1, amount + 1): left_amount = root - 1 right_amount = amount - root dp[amount] += dp[left_amount] * dp[right_amount] return dp[n] 参考链接 「手画图解」详解 DP、记忆化递归 | 96.</description>
    </item>
    
    <item>
      <title>0035-search insert position</title>
      <link>https://qidi.ink/post/2021/05/13/0035-search-insert-position/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/13/0035-search-insert-position/</guid>
      <description>问题描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在数组中，返回它将会被按顺序插入的位置。
假定数组中无重复元素。
 示例1:
 输入: [1,3,5,6], 5
输出: 2
 示例2:
 输入: [1,3,5,6], 2
输出: 1
 示例3:
 输入: [1,3,5,6], 7
输出: 4
 示例4:
 输入: [1,3,5,6], 0
输出: 0
  代码 class Solution: def searchInsert(self, nums: List[int], target: int) -&amp;gt; int: sz = len(nums) if not sz: return 0 if nums[-1] &amp;lt; target: return sz left, right = 0, sz - 1 while left &amp;lt; right: mid = left + (right - left) // 2 if nums[mid] &amp;gt;= target: right = mid else: left = mid + 1 return left 参考链接 写对二分查找不能靠模板，需要理解加练习 （附练习题，持续更新）</description>
    </item>
    
    <item>
      <title>0704-binary search</title>
      <link>https://qidi.ink/post/2021/05/12/0704-binary-search/</link>
      <pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/12/0704-binary-search/</guid>
      <description>问题描述 给定一个n个元素的升序整数数组nums和一个目标值target。
搜索nums中的target，如果目标值存在返回下标，否则返回-1。
 示例1:
 输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
 示例2:
 输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
 提示:
 数组nums中所有元素不重复 n在[1, 10000]之间 nums每个元素在[-9999, 9999]之间   代码 class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: left, right = 0, len(nums) - 1 while left &amp;lt;= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid if nums[mid] &amp;lt; target: left = mid + 1 else: right = mid - 1 return -1 </description>
    </item>
    
    <item>
      <title>0207-course schedule</title>
      <link>https://qidi.ink/post/2021/05/11/0207-course-schedule/</link>
      <pubDate>Tue, 11 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/11/0207-course-schedule/</guid>
      <description>问题描述 设在某个学期需要选修numCourses门课程，记为0到numCourses - 1。
在选修某些课程之前需要一些先修课程。先修课程按数组prerequisites给出，其中prerequisites[i] = [ai, bi]，表示如果要学习课程ai则必须先学习课程bi。
如，先修课程对[0, 1]表示：学习课程0之前需要完成课程1。
判断是否可能完成所有课程的学习？如果可以，返回true，否则返回false。
 示例1:
 输入: numCourses = 2, prerequisites = [[1,0]]
输出: true
 示例2:
 输入: numCourses = 2, prerequisites = [[1,0], [0,1]]
输出: false
 提示:
 1 &amp;lt;= numCourses &amp;lt;= 105 0 &amp;lt;= prerequisites.length &amp;lt;= 5000 prerequisites[i].length == 2 0 &amp;lt;= ai, bi &amp;lt; numCourses prerequisites[i] 中所有的课程对互不相同   代码 class Solution: def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&amp;gt; bool: # 入度矩阵 inDegree = [0] * numCourses # 后继课程列表 suc = collections.</description>
    </item>
    
    <item>
      <title>0098- validate binary search tree</title>
      <link>https://qidi.ink/post/2021/05/10/0098-validate-binary-search-tree/</link>
      <pubDate>Mon, 10 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/10/0098-validate-binary-search-tree/</guid>
      <description>问题描述 给定一个二叉树，判断其是否是一个有效的二叉搜索树。
假设一个二叉搜索树具有如下特征：
 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。   示例1:
 输入: [2, 1, 3]
输出: true
 示例2:
 输入: [5, 1, 4, null, null, 3, 6]
输出: false
  代码 中序遍历+递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: pre = float(&amp;#39;-inf&amp;#39;) def isValidBST(self, root: TreeNode) -&amp;gt; bool: if not root: return True if not self.</description>
    </item>
    
    <item>
      <title>0322-coin change</title>
      <link>https://qidi.ink/post/2021/05/09/0322-coin-change/</link>
      <pubDate>Sun, 09 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/09/0322-coin-change/</guid>
      <description>问题描述 给定不同面额的硬币coins和一个总金额amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1。
可以认为每种硬币的数量是无限的。
 示例1:
 输入: coins = [1, 2, 5], amount = 11
输出: 3
 示例2:
 输入: coins = [2], amount = 3
输出: -1
 示例3:
 输入: coins = [1], amount = 0
输出: 0
 示例4:
 输入: coins = [1], amount = 1
输出: 1
 示例5:
 输入: coins = [1], amount = 2
输出: 2
 提示:
 1 &amp;lt;= coins.</description>
    </item>
    
    <item>
      <title>🚩 0279-perfect squares</title>
      <link>https://qidi.ink/post/2021/05/08/0279-perfect-squares/</link>
      <pubDate>Sat, 08 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/08/0279-perfect-squares/</guid>
      <description>问题描述 给定正整数n，找到若干个完全平方数（比如1, 4, 9, 16, ...）使得它们的和等于n。
返回和为n的完全平方数的最少数量。
完全平方数是一个整数，其值等于另一个整数的平方。即其值等于一个整数自身的积。例如，1、4、9和16都是完全平方数，而3和11不是。
 示例1:
 输入: n = 12
输出: 3
解释: 12 = 4 + 4 + 4
 示例2:
 输入: n = 13
输出: 2
解释: 13 = 4 + 9
 提示: 1 &amp;lt;= n &amp;lt;= 104
 代码 动态规划 class Solution: def numSquares(self, n: int) -&amp;gt; int: squares = [i ** 2 for i in range(1, int(math.sqrt(n)) + 1)] dp = [float(&amp;#39;inf&amp;#39;)] * (n + 1) dp[0] = 0 for i in range(1, n+1): for square in squares: if square &amp;gt; n: break dp[i] = min(dp[i], 1 + dp[i - square]) 贪心枚举 class Solution: def numSquares(self, n: int) -&amp;gt; int: self.</description>
    </item>
    
    <item>
      <title>0236-lowest common ancestor of a binary tree</title>
      <link>https://qidi.ink/post/2021/05/07/0236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Fri, 07 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/07/0236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>问题描述 给定二叉树，找到该树中两个指定节点的最近公共祖先。
最近公共祖先的的定义为：“对于有根树T的两个节点p和q，最近公共祖先表示为一个节点x，满足 x是p、q的祖先且x的深度尽可能大（一个节点也可以是它自己的祖先）”。
 提示:
 树中节点数目在范围[2, 105]内。 -109 &amp;lt;= Node.val &amp;lt;= 109。 所有Node.val互不相同。 p != q p和q均存在于给定的二叉树中。   代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None class Solution: def lowestCommonAncestor(self, root: &amp;#39;TreeNode&amp;#39;, p: &amp;#39;TreeNode&amp;#39;, q: &amp;#39;TreeNode&amp;#39;) -&amp;gt; &amp;#39;TreeNode&amp;#39;: if not root: return None if root == p: return root if root == q: return root left = self.</description>
    </item>
    
    <item>
      <title>0337-house robber iii</title>
      <link>https://qidi.ink/post/2021/05/06/0337-house-robber-iii/</link>
      <pubDate>Thu, 06 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/06/0337-house-robber-iii/</guid>
      <description>问题描述 在一个房屋排列呈二叉树状的区域，小偷实施盗窃。
如果两个直接相连的房子同时被打劫，房屋将自动报警。
计算在不触动警报的情况下，小偷能够盗取的最高金额。
 示例1:
 输入: [3,2,3,null,3,null,1]
 3 / \ 2 3 \ \ 3 1  输出: 7
解释: 小偷一晚能够盗取的最高金额为3 + 3 + 1 = 7.
 示例2:
 输入: [3,4,5,1,3,null,1]
 3 / \ 4 5 / \ \ 1 3 1  输出: 9
解释: 小偷一晚能够盗取的最高金额为4 + 5 = 9.
  代码 递归+哈希（超时） # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.</description>
    </item>
    
    <item>
      <title>🚩 0114-flatten binary tree to linked list</title>
      <link>https://qidi.ink/post/2021/05/05/0114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/05/0114-flatten-binary-tree-to-linked-list/</guid>
      <description>问题描述 给定二叉树的根节点root，将它展开为一个单链表：
 展开后的单链表应该同样使用TreeNode，其中right子指针指向链表中下一个结点，而左子指针始终为null。 展开后的单链表应该与二叉树先序遍历顺序相同。   示例1:
 1 1 / \ \ 2 5 =&amp;gt; 2 / \ \ \ 3 4 6 3 \ 4 \ 5 \ 6   输入: root = [1,2,5,3,4,null,6]
输出: [1,null,2,null,3,null,4,null,5,null,6]
 示例2:
 输入: root = []
输出: []
 示例3:
 输入: root = [0]
输出: [0]
 提示:
 树中结点数在范围[0, 2000]内 -100 &amp;lt;= Node.val &amp;lt;= 100   代码 递归 # Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>0152-maximum product subarray</title>
      <link>https://qidi.ink/post/2021/05/04/0152-maximum-product-subarray/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/04/0152-maximum-product-subarray/</guid>
      <description>问题描述 给定整数数组nums，找出数组中乘积最大的连续子数组对应的乘积。
 示例1:
 输入: [2,3,-2,4]
输出: 6
解释: 子数组[2,3]有最大乘积。
 示例2:
 输入: [-2,0,-1]
输出: 0
解释: 结果不能为2，因为[-2,-1]不是子数组。
 提示:
 nums至少包含一个数字。   代码 class Solution: def maxProduct(self, nums: List[int]) -&amp;gt; int: if len(nums) == 1: return nums[0] res = maxval = minval = nums[0] for num in nums[1:]: maxval, minval = max(num, maxval * num, minval * num), min(num, minval * num, maxval * num) res = max(res, maxval) return res 分析  记maxval和minval分别标识以当前元素结尾的子数组的最大连续乘积和以当前元素结尾的子数组的最小连续乘积。 采用动态规划的思路，即当前元素为num：  若num为正：  若maxval &amp;gt; 0，则maxval更新为maxval * num。 若maxval &amp;lt;= 0，则maxval更新为num。 若minval &amp;lt; 0，则minval更新为minval * num。 若minval &amp;gt;= 0，则minval更新为num。   若num为负：  若minval &amp;lt; 0，则maxval更新为minval * num。 若minval &amp;gt;= 0，则maxval更新为num。 若maxval &amp;gt; 0，则minval更新为maxval * num。 若maxval &amp;lt;= 0，则minval更新为num。   若num为零：  maxval更新为0。 minval更新为0。     上述分析内蕴条件maxval &amp;gt;= minval。 在一趟遍历的过程中用变量res记录各处maxval中的最大值。 注意到maxval取值在maxval * num、num、minval * num中取得。因此可以利用max函数从三者中取得最大值，从而避免较为复杂的if else讨论。  minval的更新同理。    参考链接 详细通俗的思路分析，多解法</description>
    </item>
    
    <item>
      <title>0139-word break</title>
      <link>https://qidi.ink/post/2021/05/03/0139-word-break/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/03/0139-word-break/</guid>
      <description>问题描述 给定一个非空字符串s和一个包含非空单词的列表wordDict，判定s是否可以被空格拆封为一个或多个在字典中出现的单词。
 说明：
 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。  示例1:
 输入: s = &amp;quot;leetcode&amp;quot;, wordDict = [&amp;quot;leet&amp;quot;, &amp;quot;code&amp;quot;]
输出: true
 示例2:
 输入: s = &amp;quot;applepenpple&amp;quot;, wordDict = [&amp;quot;apple&amp;quot;, &amp;quot;pen&amp;quot;]
输出: true
 示例3:
 输入: s = &amp;quot;catsandog&amp;quot;, wordDict = [&amp;quot;cats&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;sand&amp;quot;, &amp;quot;and&amp;quot;, &amp;quot;cat&amp;quot;]
输出: false
  </description>
    </item>
    
    <item>
      <title>🚩 0142-linked list cycle ii</title>
      <link>https://qidi.ink/post/2021/05/03/0142-linked-list-cycle-ii/</link>
      <pubDate>Mon, 03 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/03/0142-linked-list-cycle-ii/</guid>
      <description>问题描述 给定一个链表，返回链表开始入环的第一个节点。如果链表无环，则返回null。
为了表示给定链表中的环，使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。 如果pos是-1，则在该链表中没有环。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: 返回索引为1的链表节点
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: 返回索引为0的链表节点
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: 返回null
解释: 链表中没有环。
 提示;
 链表中节点数目范围在[0, 104]内。 -105 &amp;lt;= None.val &amp;lt;= 105。 pos的值为-1或链表中的一个有效索引。 不允许修改给定的链表。 考虑使用O(1)空间复杂度解决此问题。   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>0039-combination sum</title>
      <link>https://qidi.ink/post/2021/05/02/0039-combination-sum/</link>
      <pubDate>Sun, 02 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/02/0039-combination-sum/</guid>
      <description>问题描述 给定一个无重复元素的数组candidates和一个目标数target，找出candidates中所有可以使数字和为target的组合。
candidates中的数字可以无限制重复被选取。
 说明:
 所有数字（包括target）都是正整数。 解集不能包含重复的组合。  示例1:
 输入: candidates = [2,3,6,7], target = 7
输出: [[7], [2,2,3]]
 示例2:
 输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2], [2,3,3], [3,5]]
 提示:
 1 &amp;lt;= candidates.length &amp;lt;= 30 1 &amp;lt;= candidates[i] &amp;lt;= 200 candidates中的每个元素都是独一无二的。 1 &amp;lt;= target &amp;lt;= 500   代码 class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: candidates.sort() res = list() def backtrack(begin: int, end: int, target: int, tmp: List[int]) -&amp;gt; None: for i in range(begin, end): if candidates[i] == target: res.</description>
    </item>
    
    <item>
      <title>0078-subsets</title>
      <link>https://qidi.ink/post/2021/05/01/0078-subsets/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/01/0078-subsets/</guid>
      <description>问题描述  给定整数数组nums，数组中的元素互不相同。 返回所有可能的子集（幂集）。 解集不能包含重复的子集。可以按任意顺序返回解集。   示例1
 输入: nums = [1,2,3]
输出: [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]
 示例2
 输入: nums = [0]
输出: [[], [0]]
 提示
 1 &amp;lt;= nums.length &amp;lt;= 10 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums中的所有元素互不相同   代码 class Solution def subsets(self, nums: List[int]) -&amp;gt; List[List[int]]: res = list() def backtrack(index: int, tmp: List[int]) -&amp;gt; None: res.append(tmp[:]) for i in range(index, len(nums)): tmp += [nums[i]] backtrack(i+1, tmp) tmp.</description>
    </item>
    
    <item>
      <title>0690-employee importance</title>
      <link>https://qidi.ink/post/2021/05/01/0690-employee-importance/</link>
      <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/05/01/0690-employee-importance/</guid>
      <description>问题描述 给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度和直系下属的id。
比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15，10，5。那么员工1的数据结构式[1,15,[2]]，员工2的数据结构是[2,10,[3]，员工3的数据结构是[3,5,[]]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。
 示例
 输入: [[1,5,[2,3]], [2,3,[]], [3,3,[]]], 1
输出: 11
 提示
 一个员工最多有一个直系领导，但是可以有多个直系下属 员工数量不超过2000   代码 &amp;#34;&amp;#34;&amp;#34; # Definition for Employee. class Employee: def __init__(self, id: int, importance: int, subordinates: List[int]): self.id = id self.importance = importance self.subordinates = subordinates &amp;#34;&amp;#34;&amp;#34; class Solution: def getImportance(self, employees: List[&amp;#39;Employee&amp;#39;], id: int) -&amp;gt; int: if not employees: return 0 hashTable = dict() for index, employee in enumerate(employees): hashTable[employee.</description>
    </item>
    
    <item>
      <title>0046-permutations</title>
      <link>https://qidi.ink/post/2021/04/30/0046-permutations/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/30/0046-permutations/</guid>
      <description>问题描述 给定一个没有重复数字的序列，返回其所有可能的全排列。
 示例:
 输入: [1,2,3]
输出: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
  代码 自研递归 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: if len(nums) == 1: return [nums] for i in range(len(nums)): for permutation in self.permute(nums[:i] + nums[i+1:]): res.append(permutation + [nums[i]]) return res 与自研代码思路相同，可读性更高 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: def DFS(nums: List[int], tmp: List[int]) -&amp;gt; List[List[int]]: if not nums: res.append(tmp) eles: for i, element in enumerate(nums): DFS(nums[:i] + nums[i+1:], tmp + [element]) res = list() DFS(nums, []) return res 标准回溯 class Solution: def permute(self, nums: List[int]) -&amp;gt; List[List[int]]: def backtrack(nums: List[int], size: int, depth: int, used: List[bool], permutation: List[int]) -&amp;gt; List[List[int]]: if depth == size: res.</description>
    </item>
    
    <item>
      <title>第7章 C控制语句：分支和跳转</title>
      <link>https://qidi.ink/cs/cprimerplus/7-c/</link>
      <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/7-c/</guid>
      <description>智能的一个方面是：根据情况做出相应的响应。 选择语句是开发具有智能行为程序的基础。 C语言通过if、if else和switch语句以及条件运算符(?:)可以实现智能选择。  if语句  if语句用于选择是否执行一个行为，又称为分支语句或选择语句。相当于一个交叉点。  if ( expression ) statement  if else语句用于在两个行为之间选择。if else语句的通用形式是：  if ( expression ) statement1 else statement2  if和else之间只允许有一条简单语句或复合语句。 整个if else语句被视为一条语句。 如果没有花括号，else与离它最近的if匹配。 在else后面适用另一个if语句形成else if，可以构造多选一的结构。  if ( expression1 ) statement1 else if ( expression2 ) statement2 else statement3  除非最近的if被花括号括起来。 if和if else语句使用测试条件判断执行哪些语句。测试通常涉及关系表达式、逻辑表达式。  getchar()和putchar()  getchar()和putchar()函数定义在头文件stdio.h中。 getchar()和putchar()是预处理宏，不是真正的函数。 getchar()函数不带任何参数，从输入队列中返回下一个字符。  ch = getchar()等效于scanf(&amp;quot;%c&amp;quot;, &amp;amp;ch)。   putchar()函数打印它的参数。  putchar(ch)等效于printf(&amp;quot;%c&amp;quot;, ch)。   getchar()和putchar()函数只处理字符，它们比通用的scanf()和printf()函数更快。 getchar()和putchar()函数不需要转换说明。 putchar()函数接受int类型参数，该函数只根据最后一个字节确定显示哪个字符。  ctype.</description>
    </item>
    
    <item>
      <title>0056-merge intervals</title>
      <link>https://qidi.ink/post/2021/04/29/0056-merge-intervals/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/29/0056-merge-intervals/</guid>
      <description>问题描述 以数组intervals表示若干个区间的集合，其中单个区间为intervals[i] = [start_i, end_i]。
要求合并所有的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
 示例1:
 输入: intervals = [[1,2], [2,6], [8,10], [15,18]]
输出: [[1,6], [8,10], [15,18]]
解释: 区间[1,3] 和[2,6]重叠，将它们合并为[1,6]。
 示例2:
 输入: intervals = [[1,4], [4,5]]
输出: [[1,5]]
解释: 区间[1,4] 和[4,5]可被视为重叠区间。
 提示:
 1 &amp;lt;= intervals.length &amp;lt;= 104 intervals[i].length == 2 0 &amp;lt;= start_i &amp;lt;= end_i &amp;lt;= 104   代码 class Solution: def merge(self, intervals: List[List[int]]) -&amp;gt; List[List[int]]: intervals.sort(key = lambda x: x[0]) res = [] for interval in intervals: if not res: res.</description>
    </item>
    
    <item>
      <title>第6章 C控制语句：循环</title>
      <link>https://qidi.ink/cs/cprimerplus/6-c/</link>
      <pubDate>Thu, 29 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/6-c/</guid>
      <description>对于计算机科学而言，一门语言应该提供以下三种形式的程序流：
 执行语句序列。 如果满足某些条件就重复执行语句序列（循环）。 通过测试选择执行哪一个语句序列（分支）。  伪代码pseudocode
 用简单的句子表示程序思路的方法，与计算机语言的形式相对应。 伪代码有助于设计程序的逻辑，将注意力集中在程序的组织和逻辑上。 确定程序逻辑无误后，将伪代码翻译成实际的编程代码。  入口条件循环  条件指的是语句部分的执行取决于测试表达式描述的条件。 while循环中的测试条件是入口条件。必须满足条件才能够进入循环体。 入口条件循环可能不执行循环。  while语句  借助scanf()函数，while语句中允许将获取值和判断值放在一处。  while (scanf(&amp;#34;%ld&amp;#34;, &amp;amp;num) == 1) { /* 循环行为 */ }  while循环的通用形式为  while (expression) statement  statement部分可以是单独的简单语句或复合语句。  复合语句再语句构成上也是一条单独的语句。 C语言中，单独的分号表示空语句，空语句不执行任何操作。  当所有的任务都在测试条件中完成时，可以使用带空语句的while语句。 while (scanf(&amp;quot;%d&amp;quot;, &amp;amp;num) == 1) ; /* 跳过输入到达第一个既非空白字符也非数字的位置 */ 为提高代码可读性，空语句应单独占据一行。 处理这种情况的更好方法是使用continue语句。     每次循环称为一次迭代iteration。 构建while循环时，必须让测试表达式的值有变换。即测试表达式最终要为假，否则循环不会终止。  只有在对测试条件求值时，才决定是否继续循环。   关系运算符常用于构造关系表达式。  比较浮点数时，尽量只使用&amp;lt;和&amp;gt;。 浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。  fabs()函数可以用于比较两浮点数是否足够接近。   关系表达式的真值为1，假值为0。  一般而言，在C中，所有的非零值都视为真，只有0视为假。   为避免误用赋值运算符作为相等运算符，可在常量比较时，将常量置于表达式左侧。  C语言不允许给常量赋值，编译器会标记这种用法为语法错误。   关系运算符的优先级比算术运算符低，比赋值运算符高。  &amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=是高优先级的关系运算符。 ==、!</description>
    </item>
    
    <item>
      <title>第5章 运算符、表达式和语句</title>
      <link>https://qidi.ink/cs/cprimerplus/5/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/5/</guid>
      <description>基本运算符  C语言用 运算符(operator) 表示算术运算。 运算对象(operand)是运算符操作的对象。  赋值运算符  C语言中，=不意味着相等，而是一个赋值运算符。 赋值表达式语句的目的是把值存储到内存位置上。 用于存储值的数据存储区域称为数据对象（data object）。 左值：用于标识特定数据对象的名称或表达式。  用const创建的变量不可修改。  用const创建的变量指定一个数据对象，但不可用在赋值运算符的左侧。   可修改的左值：用于标识可修改的数据对象。   赋值运算符的左侧应该是可修改的左值（对象定位值）。 右值：能赋值给可修改左值的量，是一种表达式的值。如常量、变量、可求值的表达式。 C语言中其他赋值运算符包括+=、-=、*=、/=、%=。  加、减、符号、乘法、除法运算符  加法运算符+用于加法运算，使其两侧的值相加。相加的值可以是变量也可以是常量。 减法运算符-用于减法运算，使其左侧的数减去右侧的数。  +和-运算符为二元运算符。   符号运算符-和+：  -可以用于标明或改变一个值的代数符号。  以这种方式使用的负号为一元运算符。   C90标准新增了一元运算符+，它不会改变运算对象的值或符号。  dozen = +12。     乘法运算符*用于乘法运算。 除法运算符/用于除法运算。  /左侧的值是被除数，右侧的值是除数。 浮点数除法结果是浮点数，整数除法的结果是整数。  正整数除法采用截断处理，丢弃除法结果的小数部分。 C99标准建议负数的整数整数采用趋零截断。   混合整数和浮点数的计算结果是浮点数。  计算机会把两个运算对象转换成相同的类型。这种情况下会把整数转换成浮点数。      运算符优先级  C语言通过运算符优先级解决运算符操作顺序的问题。 上述运算符的优先级依次为：括号运算符、一元符号运算符、乘除运算符、加减运算符、赋值运算符。  若两运算符共享一个运算对象，则优先级决定了求职顺序。 若两运算符优先级相同且处理同一个运算对象，则根据它们在语句中出现的顺序执行。 若两运算符优先级相同，但不处理同一个运算对象，C并未规定先进行哪一个运算。因具体实现而异。    sizeof运算符  sizeof运算符以字节为单位返回运算对象的大小。C规定sizeof运算符返回size_t类型的值。 C语言有一个typedef机制，允许为现有类型创建别名。  如typedef double real;。real将作为double的别名。   C语言规定，sizeof返回size_t类型的值。  C头文件系统使用typedef将sizt_t作为unsigned int或unsigned long的别名。 在使用sizt_t类型时，编译器会根据不同的系统替换标准类型。   C99标准新增了%zd转换说明用于printf()显示sizt_t类型的值。  求模运算符  求模运算符常用于控制程序流。 求模运算符给出其左侧整数除以右侧整数的余数。 对于负数求模，在C99规定趋零截断之后  若第一个运算对象是负数，那么求模结果也是负数。 若第一个运算对象是正数，那么求模结果也是正数。 若a和b都是整数值，则可以通过a - (a/b)*b来计算a%b。    递增运算符/递减运算符  递增运算符使其运算对象递增1。 前缀模式：++出现在操作对象之前。  ++x：在使用x的值之前，递增x。 x++：在使用x的值之后，递增x。   后缀模式：++出现在操作对象之后。 每种形式的递增运算符都有一个递减运算符与之对应。 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。 递增递减运算符智能影像一个可修改的左值。(x*y)++的语法无效。  注：</description>
    </item>
    
    <item>
      <title>🚩0105-construct binary tree from preorder and inorder traversal</title>
      <link>https://qidi.ink/post/2021/04/28/0105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/28/0105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>问题描述 根据一棵树的前序遍历与中序遍历构造二叉树。
 示例
 输入:
 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7]  输出:
 3 / \ 9 20 / \ 15 7   注:假定树中没有重复的元素
 代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; TreeNode: self.</description>
    </item>
    
    <item>
      <title>0049-group anagrams</title>
      <link>https://qidi.ink/post/2021/04/27/0049-group-anagrams/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/27/0049-group-anagrams/</guid>
      <description>问题描述 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排序不同的字符串。
 示例:
 输入: [&amp;lsquo;eat&amp;rsquo;, &amp;lsquo;tea&amp;rsquo;, &amp;lsquo;tan&amp;rsquo;, &amp;lsquo;ate&amp;rsquo;, &amp;lsquo;nat&amp;rsquo;, &amp;lsquo;bat&amp;rsquo;]
输出: [ [&amp;lsquo;ate&amp;rsquo;,&amp;lsquo;eat&amp;rsquo;,&amp;lsquo;tea&amp;rsquo;], [&amp;lsquo;nat&amp;rsquo;, &amp;lsquo;tan&amp;rsquo;], [&amp;lsquo;bat&amp;rsquo;] ]
 说明:
 所有输入均为小写字母。 不考虑答案输出的顺序。   代码 以排序后的字符串作为键 class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: hashTable = collections.defaultdict(list) for word in strs: hashTable[&amp;#39;&amp;#39;.join(sorted(word))].append(word) return list(hashTable.values()]) 以字符串中各字母的频次统计作为键 class Solution: def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]: hashTable = collections.default(list) for word in strs: cnt = [0] * 26 for ch in word: cnt[ord(ch) - ord(&amp;#39;a&amp;#39;)] += 1 hashTable[tuple(cnt)].</description>
    </item>
    
    <item>
      <title>第4章 字符串和格式化输入/输出</title>
      <link>https://qidi.ink/cs/cprimerplus/4/</link>
      <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/4/</guid>
      <description>字符串  字符串是一系列被视为一个处理单元的字符，以双引号标识。  char类型数组和null字符  C语言没有专门用于存储字符串的变量类型。字符串存储在char类型数组中。  数组是同类型数据元素的有序序列。字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。   C语言用空字符\0标记字符串的结束。  空字符是一种非打印字符，不是数字0，其ASCII码为0。 字符串字符串是一种派生类型（char数组）。字符是一种基本类型。  常量&amp;quot;x&amp;quot;和字符常量&#39;x&#39;不同。&amp;quot;x&amp;quot;实际上由两个字符组成：&#39;x&#39;和空字符\0。   C语言中的字符串一定以空字符结束，从而用于存储字符串的字符数组的容量必须至少比待存储字符串中的字符数多1。   sizeof运算符以字节为单位给出数组的大小。  sizeof是否使用圆括号取决于运算对象是类型还是特定量。  运算对象是类型时，圆括号必不可少。如sizeof(char)。 运算对象是特定量时，圆括号可以不加。如sizeof name或sizeof(name)。     头文件string.h中的函数strlen()给出字符串中的字符长度。 C99和C11标准为sizeof运算符的返回类型添加了%zd转换说明，这对于strlen()同样适用。  对于早期的C，需要知道sizeof和strlen()返回的实际类型。通常是unsigned或unsigned long。    常量和C预处理器  在K&amp;amp;R合著的The C Programming Language中介绍过符号常量的概念。 历年C标准中，提及#define的用法之一是定义一个明示常量。 C语言中可以借助C预处理器定义明示常量。  通用格式为#define NAME value。  NAME和value之间没有等号，语句末尾也没有分号。 NAME全大写是C的一贯传统，提高了程序的可读性。 value也可以是字符和字符串常量。   编译程序时，程序中的所有明示常量NAME都会被值value替代。这一过程称为编译时替换。 符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线，但首字符不能是数字。 符号常量提高了程序的可读性和可维护性。   C90标准新增了const关键字，用于限定一个变量为只读。  const int MONTHS = 12; const关键字使得MONTHS成为一个只读值。即可以在计算中使用MONTHS，可以打印MONTHS，但是不能够更改MONTHS的值。    明示常量</description>
    </item>
    
    <item>
      <title>0238-product of array except self</title>
      <link>https://qidi.ink/post/2021/04/26/0238-product-of-array-except-self/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/26/0238-product-of-array-except-self/</guid>
      <description>问题描述 给定长度为n的整数数组nums，其中n&amp;gt;1，返回输出数组output[i]等于nums中除nums[i]之外其余各元素的乘积。
 示例
 输入：[1,2,3,4]
输出：[24,12,8,6]
 提示：数目数据保证数组之中任意元素的全部前缀元素和后缀）甚至是整个数组）的乘积都在32位整数范围内。
说明：不要使用除法，且在O(n)时间复杂度哪完成此题。
进阶：老吕在常数空间复杂度内解决这一问题。（出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
 代码 class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) L, R, res = [1] * n, [1] * n, [1] * n for i in range(1, n): L[i] = nums[i-1] * L[i-1] for j in range(n-2, -1, -1): R[j] = R[j+1] * nums[j+1] for i in range(n): res[i] = L[i] * R[i] return res class Solution: def productExceptSelf(self, nums: List[int]) -&amp;gt; List[int]: n = len(nums) res = [1] * n R = 1 for i in range(1, n): res[i] = nums[i-1] * res[i-1] for j in range(n-1, -1, -1): res[j], R = res[j] * R, R * nums[j] return res 分析  直观上可以通过以下方式解决：计算数组全部元素之积，再对数组中的每个元素x，将乘积除以x求得除自身以外数组的乘积。  若输入数组中出现0，那么本方法将会失效。   不必计算数组全部元素之积再除以给定索引处的数字得到相应的答案。可以利用索引左侧所有数字的乘积和索引右侧所有数字的乘积（前缀与后缀）相乘得到答案。  参考链接 除自身以外数组的乘积</description>
    </item>
    
    <item>
      <title>第3章 数据和C</title>
      <link>https://qidi.ink/cs/cprimerplus/3-c/</link>
      <pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/3-c/</guid>
      <description>程序离不开数据。程序利用数字、字母和文字等数据完成某些任务。
变量与常量数据  数据是承载信息的数字和字符。 在程序运行过程中没有发生变化的量称为常量。 在程序运行过程中可能会改变或被赋值的量称为变量。  数据类型关键字  C语言通过识别数据类型来区分和使用不同的数据。 常量数据一般通过用户书写的形式识别。变量则是在声明时指定其类型。 K&amp;amp;R C最初给定了七个与类型相关的关键字int、long、short、unsigned、char、float、double。 C90标准添加了关键字signed和void。 C99标准添加了关键字_Bool、_Complex和_Imaginary。 C语言中，用int关键字表示基本的整数类型。  关键字long、short、unsigned和signed用于提供基本整数类型的变式。如unsigned short int和long long int。   C语言中，用char关键字指定字母和其它字符。也可用char类型表示较小的数。 C语言中，用float、double和long double表示带小数点的数。 C语言中，_Bool类型表示布尔值，_Complex和_Imaginary分别表示复数和虚数。 通过上述关键字创建的类型，按照计算机的存储方式可以分为两大基本类型：整数类型和浮点数类型。 在某些系统化的命名约定中，在变量名中体现出变量的类型。  用i_前缀表示int类型。如i_smart。 用us_前缀表示unsigned short类型。如us_versmart。    位、字节、字  位、字节、字用于描述计算机数据单元或存储单元，主要指存储单元。 位是计算机内存的基本构建块，计算机中位的数量十分庞大。位用于设置开或关。 字节是常用的计算机存储单位。在字节的标准定义中，1字节为8位。 字是设计计算机时给定的自然存储单位。计算机的字长越大，其数据转移越快，允许的内存访问也越多。  整数  C语言中，整数是没有小数部分的数。计算机以二进制数字存储整数。  int类型  int类型是有符号整型，取值范围依系统而异。  一般而言，存储一个int要占用一个机器字长。 ISO C规定int的最小取值范围为-32768 ~ 32768。 系统用一个特殊位的值表示有符号整数的正负号。 int类型被认为是计算机处理整数类型时最高效的类型。    其它整数类型  C语言提供三个附属关键字修饰基本整数类型：short、long和unsigned。  short int类型或short占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。  C语言规定short类型至少占16位。 在给函数传递参数时，C编译器会把short类型的值自动转换成int类型的值。   long int或long占用的存储空间可能比int类型多，适用于较大数值的场合。  C语言规定long类型至少占32位。   long long int或long long（C99加入）占用的存储空间可能比long多，适用于更大数值的场合。long long类型至少占64位。  C语言规定long long类型至少占64位。   unsigned int或unsigned用于表达非负值。  unsigned类型中，用于表示正负号的位现用于表示另一个二进制位，故无符号整型可以表示更大的数。   C语言只规定short占用的存储空间不能多于int，long占用的存储空间不能少于int。  即C语言只规定了基本数据类型的最小取值范围。 这种规定是为了适应不同的机器。 在运行Windows 3.</description>
    </item>
    
    <item>
      <title>0055-jump game</title>
      <link>https://qidi.ink/post/2021/04/25/0055-jump-game/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/25/0055-jump-game/</guid>
      <description>问题描述 给定非负整数数组nums，最初位于数组的第一个下标。
数组中的每个元素代表在该位置可以跳跃的最大长度。
判定是否可以到达最后一个下标。
 示例1：
 输入：nums = [2,3,1,1,4]
输出： true
解释： 可以先跳一步，从下标0到达下标1，然后再从下标1跳3步到达最后一个下标。
 示例2：
 输入： nums = [3,2,1,0,4]
输出: false
解释：无论怎样，总会到达下标为3的位置。但该下标的最大跳跃长度是0，所以永远不可能到达最后一个下标。
 提示：
 1 &amp;lt;= nums.length &amp;lt;= 3 * 104 0 &amp;lt;= nums[i] &amp;lt;= 105   代码 Forward class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: border = 0 for i, radius in enumerate(nums): if i &amp;lt;= border: if i + radius &amp;gt;= len(nums) - 1: return True if i + radius &amp;gt; border: border = i + radius else: return False return True Backward class Solution: def canJump(self, nums: List[int]) -&amp;gt; bool: target = len(nums) - 1 for i in range(len(nums) - 2, -1, -1): if i + nums[i] &amp;gt;= target: target = i return target == 0 分析 事实1：若位置i可达，则位置i之前的位置均可达。  nums[i]可视为位置i的可达半径。  以位置i为圆心，nums[i]为可达半径，张成一个可达圆。  只考虑圆abs(theta) &amp;lt;= 90度在横轴上的投影即可。   若各可达圆的并集的投影覆盖了横轴[0, n-1]的所有点，则最后一个位置可达。   若从前向后的遍历过程发现某个位置超出了当前的可达范围，则由事实1可知，最后一个位置无法到达。  从前向后的遍历过程不能够跃过某些点，因为某个点可能蕴含着更大的可达范围。   若遍历过程中发现可达范围已包含最后一个位置，则返回true。  事实2：若位置i可达，则可达圆包含位置i且最近临位置i的位置j一定可达。  事实2可用反证法证明：倘若位置j不可达，由位置i的可达性知，必存在位置k的可达圆包含位置i，又位置k的可达圆一定包含位置i，故矛盾，因此位置j可达。 假设最后一个位置可达，由事实2知，问题可转换为收敛圆包含最后一个位置的最近邻位置是否可达。并转换为具有相同结构的子问题。 这种可达性在传递过程中下标递减。因此若最后一个位置可达，则链条的最后一环将是位置0。 若反向传播过程中发现某个位置不可达，则说明最后一个位置不可达。  </description>
    </item>
    
    <item>
      <title>第2章 C语言概述</title>
      <link>https://qidi.ink/cs/cprimerplus/2-c/</link>
      <pubDate>Sun, 25 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/2-c/</guid>
      <description>程序可看作希望计算机如何完成任务的描述。 编译器负责将程序转换为机器语言。 由于编译器不具有真正的智能，因此必须用编译器能理解的特定格式的指令表达意图。这些特定格式的指令就是C语言标准规定的形式规则。 编写C程序即是在符合C标准的编译器框架下，表达程序如何完成任务的想法。  demo #include&amp;lt;stdio.h&amp;gt;int main(void) { int num; num = 1; printf(&amp;#34;I am a simple &amp;#34;); printf(&amp;#34;computer.\n&amp;#34;); printf(&amp;#34;My favorite number is %d because it is first.\n&amp;#34;, num); return 0 }  C程序由一个或多个函数组成，必须有main()函数。  函数由函数头和函数体组成。  函数头包含函数名、传入该函数的信息类型和函数的返回类型。 函数体被花括号扩起来，由一系列语句、声明组成。   通过函数名后的圆括号可识别出函数。  圆括号内可能为空，可能有参数。     C语言中有关键字、标识符、运算符、数据。 C语言中有六种语句：标号语句、复合语句、表达式语句、选择语句、迭代语句·、跳转语句。  C语言中的函数调用是一种后缀表达式语句。    解释 #include指令和头文件  #include&amp;lt;stdio.h&amp;gt;是一种拷贝-粘贴的操作。相当于将stdio.h文件中的所有内容都输入到该行所在的位置。 标准输入输出头文件stdio.h是C编译器软件包的标准部分，提供键盘输入和键盘输出的支持。  在C程序顶部的信息被称为头文件。 头文件包含了编译器创建最终可执行程序要用到的信息。 不将输入和输出作为语言内置功能体现了C语言经济实用资源的原则，这种原则使得C语言成为流行的嵌入式编程语言。   #include&amp;lt;stdio.h&amp;gt;是一条预处理指令。  C编译器在变异之前会对源代码做一些准备工作，称为预处理。    main()函数  函数是C程序的基本模块。圆括号用于对函数的标识。 C程序从**main()**函数开始执行。  C编译器允许main()没有参数或有两个参数。一些实现允许main()有更多参数，属于对标准的扩展。  int main(void)是标准ANSI C定义main()的一部分。      注释  C语言中被/* */两个符号扩起来的部分是程序的注释。  /* 这是一条C注释 */ /* 也可以这样写C注释 */  C99中新增了//风格的注释。这种风格的注释只能写成一行。  花括号、函数体和块  花括号用于把函数中的多条语句合并为一个单元或块。C函数使用花括号标记函数体的开始和结束。  声明  标识符是变量、函数或其他实体的名称。 声明是C语言最重要的特性之一。声明完成了两件事：  将特定标识符与计算机内存中的特定位置联系起来。 确定存储在特定位置的数据类型。   编译器使用上述信息为标识符在内存中分配存储空间。 分号在C语言中是大部分语句和声明的一部分，不只是语句间的分隔符。 C语言中，所有变量都必须先声明才能使用，这意味着必须列出程序中用到的所有变量名及其类型。 以前的C语言要求把变量声明在块的顶部，任何其他语句不能出现在声明之前。 C99和C11遵循 C++ 的惯例，允许将声明放在块中的任何位置，但首次使用变量前需要先进行声明。  赋值  C语言通过赋值运算符完成赋值操作。 C语言的赋值操作是一种赋值表达式语句。  return语句  C语言中return语句是一种跳转语句。 int main(void)中的int表明main()函数应返回一个整数。这是C标准要求之一。 return语句在UNIX、Linux等操作系统中有实际用途。  提高程序可读性  选择有意义的函数名。 适当地添加注释。 在函数中用空行分隔概念上的多个部分。 每条语句各占一行。  函数原型  C90标准新增了函数原型。 函数原型是一种声明形式，告知编译器正在使用某函数。 C的惯例是将main()放在开头，它提供了程序的基本框架。 C标准建议为程序中用到的所有函数提供函数原型。  标准include文件为标准库函数提供了函数原型。    调试程序 语法错误  语法是一套规则，用于管理语言中各有效语句组合在一起的方式。 不遵循C语法规则会导致语法错误。  语义错误  语义是语句要表达的意思。 语义错误表现的程序的行为中。检查语义错误要跟踪程序状态。  程序状态  程序状态是在程序的执行过程中，某给定点上所有变量值的集合，是计算机当前状态的一个快照。  错误与警告  如果输入程序时打错，编译器会报告语法错误信息。错误信息表明程序中有错，不能进行编译。 编译器有时会给出一些警告。警告表明尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译。  跟踪程序状态的方法有：</description>
    </item>
    
    <item>
      <title>0001-two sum</title>
      <link>https://qidi.ink/cs/dsaa/0001-two-sum/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/dsaa/0001-two-sum/</guid>
      <description>problem description </description>
    </item>
    
    <item>
      <title>0048-rotate image</title>
      <link>https://qidi.ink/post/2021/04/24/0048-rotate-image/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/24/0048-rotate-image/</guid>
      <description>问题描述 给定一个n级矩阵matrix表示一个图像。请将图像顺时针旋转90度。
考虑原地旋转图像，即直接修改输入的二维数组，不借助另一个矩阵来旋转图像。
 示例1:
 输入: matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出: matrix = [[7,4,1],[8,5,2],[9,6,3]]
 示例2:
 输入: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出: matrix = [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
 示例3:
 输入: matrix = [[1]]
输出: matrix = [[1]]
 示例4:
 输入: matrix = [[1,2],[3,4]]
输出: matrix = [[3,1],[4,2]]
 提示:
 matrix.length == n matrix[i].length == n 1 &amp;lt;= n &amp;lt;= 20 -1000 &amp;lt;= matrix[i][j] &amp;lt;= 1000   代码 自研 class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: i, j = 0, len(matrix) - 1 while i &amp;lt; j: for k in range(i, j): matrix[i][k], matrix[k][j], matrix[j][j-k+i], matrix[j-k+i][i] = matrix[j-k+i], matrix[i][k], matrix[k][j], matrix[j][j-k+i] i += 1 j -= 1 用翻转代替旋转 class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: n = len(matrix) for i in range(n // 2): for j in range(n): matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j] for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] 分析  对于行标、列标分别为row、col的元素matrix[row][col]，在旋转变换作用下将映射到matrix[col][n-1-row]。 对于水平翻转结合对称变换，可注意到元素matrix[row][col]先变换为matrix[n-1-row][col]，再变换为matrix[col][n-1-row]。故水平翻转结合对称变换等价于旋转变换。 也可以结合递归思想，由外向内地逐方框进行旋转变换。可以用i、j分别指向方框的最小行标（最小列标）、最大行标（最大列标）。结合下图可实现旋转变换。   </description>
    </item>
    
    <item>
      <title>第1章 初识C语言</title>
      <link>https://qidi.ink/cs/cprimerplus/1-c/</link>
      <pubDate>Sat, 24 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/cs/cprimerplus/1-c/</guid>
      <description>C语言的起源  1972年，贝尔实验室的Dennis Ritch和Ken Thompson在开发Unix操作系统时设计了C语言。 C语言基于B语言进行设计。  C语言的特点 设计特性  C语言易于完成自顶向下的规划、结构化编程和模块化设计。 C语言编写的程序更可靠和具有可读性。  高效性  C相对更加紧凑，运行速度很快。 具有通常是汇编语言才具有的微调控制能力，可以根据具体情况微调程序来获得最大运行速度或最有效地使用内存。  可移植性  计算机系统的硬件平台在指令系统和编码格式上有很大差异，同一可执行程序无法在所有平台上运行。 为保证开发的程序能够兼容其他平台，需要针对目标平台，将高级程序设计语言的源代码文件进行修改和再次编译。生成目标系统的适配可执行应用程序。 程序语言的可移植性是指通过编译器，将源代码编译，生成对目标系统的可执行程序。 C在多种软硬件平台上有广泛的支持，C99、C11语言标准也可以很好的向下兼容。C语言具有较好的可移植性。  强大而灵活  UNIX操作系统大部分由C语言编写。 PORTAN、Perl、Python、LISP、Logo、BASIC等语言的许多编译器和解释器由C编写。 C程序可解决物理学和工程学的问题、制作电影动画特效等。  面向程序员  C语言允许程序员访问硬件、操作内存中的位。 C语言具有丰富的运算符，能让程序员简洁的表达意图。  C语言应用范围  C在Linux开发中扮演着重要角色。 C是嵌入式系统开发的流行语言。 C在科学编程领域与FORTAN分得一杯羹。 C++在C的基础上嫁接了面向对象编程工具。  C++几乎是C的超集，任何C程序差不多就是一个 C++ 程序。 面向对象编程通过对语言建模来适应问题，而非对问题建模来适应语言。    计算机工作原理  存储在计算机中的所有内容都是数字。  计算机以数字形式存储数字和字符，每个字符都有一个数字码。 计算机载入寄存器的指令也以数字形式存储，指令集的每条代码都有一个数字码。   计算机程序最终必须以数字指令码表示。 高级语言以抽象方式描述行为，不受限于特定CPU或指令集。 编译器将高级语言程序翻译成计算机能够理解的机器语言指令集。  尽管不同的CPU制造商使用的指令系统和编码格式不同，但可以找到与特定类型CPU匹配的编译器。 通过使用合适的编译器或编译器集，可以把一种高级语言程序转换成供各种不同类型CPU使用的机器语言程序。    语言标准  编写C程序时，若未使用机器特定的编程技术，程序运行情况应与C实现无关。 为此，不同的实现要遵循一个标准。  K&amp;amp;R C  1978年，Brian Kernighan和Dennis Ritchie合著的The C Programming Language第一版是公认的C标准。通常称之为K&amp;amp;R C或经典C。  The C Programming Language附录中的C语言参考手册成为实现C的指导标准。   C语言比其他语言更依赖库，因此需要一个标准库。  The C Programming Language的附录定义了C语言，但没有定义C库。 由于缺乏官方标准，UNIX实现提供的库成为了标准库。    ANSI/ISO C  随着C的不断发展，C社区意识到需要一个更全面、更新颖、更严格的标准。 美国国家标准协会ANSI于1989年公布了ANSI C标准，定义了C语言和C标准库。  ISO于1990年采用了这套C标准。  因此ISO C和ANSI C是完全相同的标准。   ANSI/ISO标准的最终版本通常叫做C89或C90。   由于ANSI先公布C标准，业界人士通常使用ANSI C。 ANSI委员会指定的指导原则中提出要保持C的精神：  信任程序员 不妨碍程序员做需要做的事 保持语言精炼简单 只提供一种方法执行一项操作 让程序运行更快，即使不能保证其可移植性  作为实现，应该针对目标计算机来定义最合适的某特定操作。而不是强加一个抽象、统一的定义。      C99  1994年，ANSI/ISO联合委员会开始修订C标准，并最终发布了C99标准。 C99标准遵循了C90标准的原则，包括保持语言的精炼简单。 委员会用意不在于向C语言中添加新特性，而是为了达到新的目标。  支持国际化编程。如提供多种方法处理国际字符集。 调整现有实践致力于解决明显的缺陷。  如根据现实生活中处理问题的经验，添加将C移至64位处理器的标准。   提高C对科学和工程项目中的关键数值计算的适应性。    C11  标准委员会在2011年发布了C11标准。 出于对编程安全的担忧，不再那么强调“信任程序员”目标。 跟进新技术的需要，如添加可选项支持使用多处理器的计算机。  C语言的编程步骤  定义程序目标  思考程序需要哪些信息，要进行哪些计算和控制，需要报告什么信息。   设计程序　 考虑如何用程序完成目标，如：数据表示和处理方法、用户界面、程序组织方式、目标用户、开发周期等。   编写代码  在编程环境中编写C语言代码。为所编写的程序添加文字注释。   编译、链接  C编译器和链接器把C代码翻译成特定的机器语言。 某些系统中需要分别运行编译和链接程序。另一些系统中，编译器会自动启动链接器，用户只需给出编译命令。   运行程序 测试和调试 维护和修改  注：规划好程序目标和设计框架，有助于编码过程中得心应手、条理清晰。</description>
    </item>
    
    <item>
      <title>0009-palindrome number</title>
      <link>https://qidi.ink/post/2021/04/23/0009-palindrome-number/</link>
      <pubDate>Fri, 23 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/23/0009-palindrome-number/</guid>
      <description>问题描述 给定整数x，如果x是一个回文整数，返回true，否则返回false。
 示例1:
 输入: x = 121
输出: true
 示例2:
 输入: x = -121
输出: false
 示例3:
 输入: x = 10
输出: false
 提示: -231 &amp;lt;= x &amp;lt;= 231 - 1
 代码 class Solution: def isPalindrome(self, x: int) -&amp;gt; bool: if x &amp;lt; 0: return False if x % 10 == 0 and x != 0: return False reverse_x = 0 while x &amp;gt; reverse_x: reverse_x = 10 * reverse_x + x % 10 x //= 10 return x == reverse_x or x == reverse_x // 10 参考链接 回文数</description>
    </item>
    
    <item>
      <title>0739-daily temperatures</title>
      <link>https://qidi.ink/post/2021/04/22/739/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/22/739/</guid>
      <description>问题描述 根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，在该位置用0代替。
 示例
 输入: temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
输出: [1, 1, 4, 2, 1, 1, 0, 0]
 提示: 气温列表长度的范围为[1, 30000]。每个气温的值均为华氏度，都是在[30, 100]范围内的整数。
 代码 class Solution: def dailyTemperatures(self, T: List[int]) -&amp;gt; List[int]: monotone_stack, res = list(), [0] * len(T) for i in range(len(T)): if not monotone_stack: monotone_stack.append(i) else: while monotone_stack and T[monotone_stack[-1]] &amp;lt; T[i]: res[monotone_stack[-1]] = i - monotone_stack[-1] monotone_stack.pop() monotone_stack.append(i) return res 分析   维护一个存储下标的单调栈，栈底至栈顶对应的温度依次递减。</description>
    </item>
    
    <item>
      <title>0200-number of islands</title>
      <link>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</link>
      <pubDate>Wed, 21 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/21/0200-number-os-islands/</guid>
      <description>问题描述 给定一个由1(陆地)和0(水)组成的二维网格，计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，可以假设网格的四条边均被水包围。
 示例1
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;]]
输出: 1
 示例2
 输入: grid = [[&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;1&amp;quot;, &amp;quot;1&amp;quot;]]
输出: 3
 提示:
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为0或1   代码 class Solution: def numIslands(self, grid: List[List[str]]) -&amp;gt; int: cnt, self.</description>
    </item>
    
    <item>
      <title>0198-house robber</title>
      <link>https://qidi.ink/post/2021/04/20/0198-house-robber/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/20/0198-house-robber/</guid>
      <description>问题描述 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。
 示例1:
 输入: [1,2,3,1]
输出: 4
 示例2:
 输入: [2,7,9,3,1]
输出: 12
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 400   代码 class Solution: def rob(self, nums: List[int]) -&amp;gt; int: if not nums: return 0 if len(nums) == 1: return nums[0] if len(nums) == 2: return max(nums[0], nums[1]) pre, cur = nums[0], max(nums[0], nums[1]) for i in range(2, len(nums)): pre, cur = cur, max(cur, pre + nums[i]) return post 分析 本问题可以用动态规划的思想进行求解。</description>
    </item>
    
    <item>
      <title>【动手学深度学习】Ch1.前言</title>
      <link>https://qidi.ink/post/2021/04/20/ch1/</link>
      <pubDate>Tue, 20 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/20/ch1/</guid>
      <description>时至今日，多数计算机程序几乎都是由软件开发人员从零编写的。为了完善业务逻辑，我们需要细致考虑应用程序所有可能 遇到的边界情况，并为这些边界情况设计合适的规则。通过不断测试直至满足需求。
在某些应用场景，我们需要程序自动调整。机器学习是一种可以从经验中学习的技术，通过采用观测数据或与环境交互的形式， 机器学习算法会积累更多的经验，其性能也会逐步提高。
使用机器学习解决问题时，需要精确定义问题，确定输入和输出性质，并选择合适模型。 模型输出由许多参数决定，使用数据集确定当下的最佳参数，这些参数通过某种性能度量 来获取完成任务的最佳性能。使用数据集来选择参数的元程序称为学习算法。学习是一个模型 的训练过程。通过这个过程，我们可以发现正确的参数集。
训练过程通常包含：
 从随机初始化参数的模型开始，这个模型基本毫不智能。 获取一些数据样本。 调整参数，使模型在这些样本中表现更好。 重复第二步和第三步，直至模型表现令人满意。  机器学习这种“通过用数据集来确定程序行为”的方法可看作是“用数据编程”。
关键组件  可以用于学习的数据 用于转换数据的模型 用于量化模型有效性的目标函数 用于调整模型参数以优化目标函数的算法  数据 数据集由一个个样本组成。多数时候，样本遵循独立同分布。
样本也称数据点或数据实例。每个样本由一组称为特征或协变量的属性组成。在监督学习问题中，机器学习模型依据这些属性预测标签。
每个样本的特征具有相同数量的特征。 即：样本特征向量长度固定。特征向量的长度称为数据的维数。
一般而言，更多的数据通常可以训练出更强大的模型，减少对预先设想假设的依赖。大规模为深度学习奠定了成功基础。 某些深度学习模型可以在小数据集上工作，但其效能不比传统方法。
仅仅拥有海量的数据是不够的，还需要正确的数据。当数据不具有充分代表性，甚至包含了一些偏见时，模型很可能会失效。
模型 深度学习关注功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换。
目标函数 机器学习被认为是从经验中学习。学习是指自主提高模型完成某些任务的效能。
需要定义模型优劣程度的度量。这个度量被称为目标函数。因此定义目标函数并将其优化到最低点。 目标函数有时也被称作损失函数。
在回归任务中，常见的损失函数是平方损失，即预测值与实际值之差的平方。
在分类任务重，常见的损失函数是错误率，即预测与实际情况不符的样本比例。
有些目标函数易于被优化，有些目标函数由于不可微性或其他复杂性难以直接优化。此时通常会优化替代目标。
损失函数通常根据模型参数定义，并取决于数据集。在某一数据集上，通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称之为训练集。训练集用于拟合模型参数，测试集用于评估拟合的模型。
优化算法 在获取了数据源及其表示、模型、适合的损失函数之后，需要一种用于搜索最佳参数以最小化损失函数的优化算法。 深度学习中多数优化算法基于梯度下降。
各种机器学习问题 监督学习 监督学习长于在给定输入特征的情况下预测标签。
  回归：当标签取任意数值时，称之为回归问题。
  分类：训练一个分类器，输出为预测的类别。
  标记：学习预测不相互排斥的类别的问题称为多标签分类。
  搜索：在信息检索领域，希望对一组项目进行排序。
  推荐：为特定用户进行个性化推荐。
  序列学习：摄取输入序列或预测输出序列，或两者兼而有之。输入和输出都是可变长度的序列。
  无监督学习 无监督学习是一种数据中不含有”目标“的机器学习问题。</description>
    </item>
    
    <item>
      <title>0031-next permutation</title>
      <link>https://qidi.ink/post/2021/04/19/0031-next-permutation/</link>
      <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/19/0031-next-permutation/</guid>
      <description>问题描述 实现获取下一个排列的函数：将给定数字序列重新排列成字典序中下一个更大的排列。
如果不存在下一个更大的排列，则将数组重新排列盛最小的序列（即升序排列）。
考虑原地修改，且只使用额外常数空间。
 示例1
 输入: nums = [1,2,3]
输出: [1,3,2]
 示例2
 输入: nums = [3,2,1]
输出: [1,2,3]
 示例3
 输入: nums = [1,1,5]
输出: [1,5,1]
 示例4
 输入: nums = [1]
输出: [1]
 提示:
 1 &amp;lt;= nums.length &amp;lt;= 100 0 &amp;lt;= nums[i] &amp;lt;= 100   代码 pre = post = -1 for pos in range(len(nums) - 1, 0, -1): if nums[pos] &amp;gt; nums[pos - 1]: pre, post = pos - 1, pos break if post == -1: nums.</description>
    </item>
    
    <item>
      <title>【动手学深度学习】数据处理</title>
      <link>https://qidi.ink/post/2021/04/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 19 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/19/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/</guid>
      <description>目标   深度学习经典模型和最新模型
  机器学习基础
  实践
  深度学习基础
 线性神经网络 多层感知机    卷积神经网络（空间）
  循环神经网络（时间）
  注意力机制
  优化算法
  高性能计算
  计算机视觉
  自然语言处理
  将要学习到什么  深度学习里有什么技术 如何实现和调参 背后的原因（直觉、数学）  资源  教材:https://zh-v2.d2l.ai/  Q&amp;amp;A  模型可解释性  有效与可解释性不同。    安装 </description>
    </item>
    
    <item>
      <title>0022-generate parentheses</title>
      <link>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/18/0022-generate-parentheses/</guid>
      <description>问题描述 设计函数，生成所有可能的并且有效的括号组合。
数字n代表生成括号的对数。
 示例1:
 输入: n = 3
输出: [&amp;quot;((()))&amp;quot;, &amp;ldquo;(()())&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, &amp;ldquo;()(())&amp;rdquo;, &amp;ldquo;()()()&amp;quot;]
 示例2:
 输入: n = 1
输出: [&amp;quot;()&amp;quot;]
 提示: 1 &amp;lt;= n &amp;lt;= 8
 代码 DFS1 class Solution: def helper(self, comb = &amp;#39;&amp;#39;, lcnt = 0, matched = 0) -&amp;gt; None: if matched == self.n: self.res.append(comb) elif matched == lcnt: self.helper(comb + &amp;#39;(&amp;#39;, lcnt + 1, matched) elif lcnt &amp;lt; self.n: self.</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch5. Pandas基础</title>
      <link>https://qidi.ink/post/2021/04/18/python-ch5-pandas/</link>
      <pubDate>Sun, 18 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/18/python-ch5-pandas/</guid>
      <description>Pandas 简介  Pandas采用了Numpy编码风格。特别是基于数组的函数和不使用for循环的数据处理。  Numpy更适合处理统一的数值数组数据。 Pandas专门为处理表格和混杂数据设计。    Pandas 数据结构 Series  Series是一种类似于一维数组的对象。由一组数据以及一组与之相关的数据标签（索引）组成。  可通过Series的values和index属性获取其数组表示形式和索引对象。 可通过指定index关键字制定索引。  obj = pd.Series([4, 7, -4, 3], index = [&#39;d&#39;, &#39;b&#39;, &#39;a&#39;, &#39;c&#39;])     由于可看作是索引值到数据值的一个映射，Series可以看成是一种定长的有序字典。  可以通过Python内置字典来创建Series。  如果只传入一个字典，则结果Series中的索引就是原字典的键（有序排列）。可以传入排序好的字典的键来改变顺序。      sdata = {&amp;#39;Ohio&amp;#39;: 35000, &amp;#39;Texas&amp;#39;: 71000, &amp;#39;Oregon&amp;#39;: 16000, &amp;#39;Utah&amp;#39;: 5000} states = [&amp;#39;California&amp;#39;, &amp;#39;Ohio&amp;#39;, &amp;#39;Oregon&amp;#39;, &amp;#39;Texas&amp;#39;] obj = pd.Series(sdata, index = states) # obj: # California NaN # Ohio 35000.</description>
    </item>
    
    <item>
      <title>0017-letter combinations of a phone number</title>
      <link>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0017-letter-combinations-of-a-phone-number/</guid>
      <description>题目描述 给定一个仅包含数字2-9的字符串，返回所有它能表示的字母组合。
给定数字到字母的映射如下（与电话按键相同）。
 示例1
 输入: digits = &amp;ldquo;23&amp;rdquo;
输出: [&amp;ldquo;ad&amp;rdquo;, &amp;ldquo;ae&amp;rdquo;, &amp;ldquo;af&amp;rdquo;, &amp;ldquo;bd&amp;rdquo;, &amp;ldquo;be&amp;rdquo;, &amp;ldquo;bf&amp;rdquo;, &amp;ldquo;cd&amp;rdquo;, &amp;ldquo;ce&amp;rdquo;, &amp;ldquo;cf&amp;rdquo;]
 示例2
 输入: digits = &amp;quot;&amp;quot;
输出: []
 示例3
 输入: digits = &amp;ldquo;2&amp;rdquo;
输出: [&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;, &amp;ldquo;c&amp;rdquo;]
 提示:
 0 &amp;lt;= digits.length &amp;lt;= 4 digits[i]是范围[&#39;2&#39;, &#39;9&#39;]的一个数字 答案可以按任意顺序返回   代码 BFS class Solution: def letterCombinations(self, digits: str) -&amp;gt; List[str]: digit = [str(x) for x in range(2, 10)] alphabet = [&amp;#39;abc&amp;#39;, &amp;#39;def&amp;#39;, &amp;#39;ghi&amp;#39;, &amp;#39;jkl&amp;#39;, &amp;#39;mno&amp;#39;, &amp;#39;pqrs&amp;#39;, &amp;#39;tuv&amp;#39;, &amp;#39;wxyz&amp;#39;] d = dict(zip(digit, alphabet)) queue = list() cnt = 0 for digit in digits: if not cnt: for alphabet in d[digit]: queue.</description>
    </item>
    
    <item>
      <title>0019-remove nth node from end of list</title>
      <link>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/0019-remove-nth-node-from-end-of-list/</guid>
      <description>删除链表的倒数第N个结点 给定一个链表，删除链表的倒数第n个结点，并返回链表的头结点。
 示例1
 输入: head = [1,2,3,4,5], n = 2
输出: [1,2,3,5]
 示例2
 输入: head = [1], n = 1
输出: []
 示例3
 输入: head = [1,2], n = 1
输出: [1]
 提示:
 链表中节点的数目为sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch4. Numpy基础 数组和矢量计算</title>
      <link>https://qidi.ink/post/2021/04/17/python-ch4-numpy/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/17/python-ch4-numpy/</guid>
      <description>ndarray: 一种多维数组对象  ndarray是一个通用的同构数据多维容器。  ndarray中所有元素必须是相同类型的。 ndarray有shape属性（表示各维度大小的元组）和dtype属性（用于说明数组数据类型的对象）    创建ndarray  array函数：将一切序列对象（含其他数组）转化为NumPy数组。 np.zeros、np.ones、np.empty分别可以创建指定长度或形状的全0或全1数组或没有任何具体值的数组。需传入一个表示形状的元组  np.empty返回数组的元素大多是未初始化的值，非全0或全1。   np.arange函数是Python内置函数range的数组版。     函数 说明     array 将输入数据（列表、元组、数组或序列类型）转换为ndarray。推断或指定dtype。创建新ndarray对象   asarray 将输入转换为ndarray，如果输入本身是ndarray对象则指向输入   arange 与内置range相似，返回ndarray对象而非列表`   ones 根据指定的形状和dtype创建一个全1数组   ones_like 以另一个数组为参数，根据其形状和dtype创建一个全1数组   zeros 根据指定的形状和dtype创建一个全0数组   zeros_like 以另一个数组为参数，根据其形状和dtype创建一个全0数组   empty 根据指定的形状和dtype创建数组，只分配内存空间不填充值   empty_like 以另一个数组为参数，根据祺形状和dtype创建数组，只分配内存空间不填充值   full 根据指定的形状和dtype创建数组，值依据参数fill_value指定   full_like 以另一个数组为参数，根据祺形状和dtype创建数组，值依据参数fill_value指定   eye 创建N阶方阵    ndarray数据类型  dtype含有ndarray将一块内存解释为特定数据类型所需的信息。  需要控制数据再内存和磁盘中的存储方式时，要了解如何控制存储类型。 narray的astype方法将数组的dtype转变后返回。当前数组不变。即创建一个新的数组。    NumPy数组运算  数组使得批量处理数据不需要借助循环。即向量化(vectorization)。  相同shape的数组之间的算术运算将作用于元素级。 数组与标量的算术运算会将标量值传播到数组各个元素。 大小相同的数组之间的比较会生成布尔值数组。  大小不同的数组之间的运算称为广播。      索引和切片  将一个标量值赋给一个切片时，该值会自动传播。  arr = np.</description>
    </item>
    
    <item>
      <title>0015-3sum</title>
      <link>https://qidi.ink/post/2021/04/16/0015-3sum/</link>
      <pubDate>Fri, 16 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/16/0015-3sum/</guid>
      <description>问题描述 给定包含n个整数的数组nums。
判断nums中是否存在三个元素a, b, c，使得a + b + c = 0？
找出所有和为0且不重复的三元组。
 示例1
 输入: nums = [-1, 0, 1, 2, -1, -4]
输出: [[-1, -1, 2], [-1, 0, 1]]
 示例2
 输入: nums = []
输出: []
 示例3
 输入: nums = [0]
输出: []
 提示:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  注意: 答案中不包含重复的三元组。
 代码 class Solution: def threeSum(self, nums: List[int]) -&amp;gt; List[List[int]]: res = [] if not nums or len(nums) &amp;lt;= 2: return res nums.</description>
    </item>
    
    <item>
      <title>0011-container with most water</title>
      <link>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/0011-container-with-most-water/</guid>
      <description>问题描述 给定n个非负整数a1,a2,...,an。每个数代表坐标中的一个点(i, ai)。在坐标内画n条垂直线，垂直线i的两个端点分别为(i,ai)和(i,0)。找出其中的两条线，使得它们与x轴共同构成的容器可以容纳最多的水。
 示例1
 输入: [1,8,6,2,5,4,8,3,7]
输出: 49
 示例2
 输入: [1,1]
输出: 1
 示例3
 输入: [4,3,2,1,4]
输出: 16
 示例4
 输入: [1,2,1]
输出: 2
 提示:
 n = height.length 2 &amp;lt;= n &amp;lt;= 3 * 104 0 &amp;lt;= height[i] &amp;lt;= 3 * 104   代码 class Solution: def maxArea(self, height: List[int]) -&amp;gt; int: l, r, res = 0, len(height) - 1, 0 while l &amp;lt; r: res = max(res, (r - l) * min(height[r], height[l])) if height[l] &amp;lt; height[r]: l += 1 elif height[l] &amp;gt; height[r]: r -= 1 else: l, r = l + 1, r - 1 return res 分析   使用双指针法搜索盛最多水时的容器边界。搜索过程中进行剪枝。</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch3. Python数据结构 函数和文件</title>
      <link>https://qidi.ink/post/2021/04/15/python-ch2-python/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/python-ch2-python/</guid>
      <description>数据结构和序列 元组  元组是一个固定长度的不可变Python序列对象。 创建元组，可用逗号分隔一列值。  In [1]: tup = 4, 5, 6  In [2]: tup Out[2]: (4, 5, 6)     用复杂的表达式定义元组，最好将值放到圆括号内。  In [3]: nested_tup = (4, 5, 6), (7, 8)  In [4]: nested_tup Out[4]: ((4, 5, 6), (7, 8))     元组是不可变对象。但元组中存储的对象可以是可变对象。  可以原地修改这些可变对象。   将元组赋值给类似元组的变量的语句，会拆分等号右边的值。  In [5]: tup = 4, 5, (6, 7)  In [6]: a, b, (c, d) = tup  In [7]: d Out[7]: 7       变量拆分常用于迭代元组或列表:  In [8]: seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]  In[9] : for a, b, c in seq: &amp;hellip;     使用*_的元组拆分:  In [10]: values = 1, 2, 3, 4, 5  In [11]: a, b, *_ = values  In [12]: _ Out[12]: [3, 4, 5]        列表   切片语法seq[::-1]返回颠倒的列表或元组。</description>
    </item>
    
    <item>
      <title>Shell Shortcuts</title>
      <link>https://qidi.ink/post/2021/04/15/shell-shortcuts/</link>
      <pubDate>Thu, 15 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/15/shell-shortcuts/</guid>
      <description>   快捷键 说明     Ctrl-P 用当前输入的文本搜索之前的命令   Ctrl-N 用当前输入的文本搜索之后的命令   Ctrl-Shift-V 从剪贴板粘贴文本   Ctrl-C 中断运行的代码   Ctrl-A 将光标移动到当前行的开头   Ctrl-E 将光标移动到当前行的末尾   Ctrl-K 删除光标到行末的文本   Ctrl-U 删除当前行的所有文本   Ctrl-F 光标向行末移动一个字符   Ctrl-B 光标向行首移动一个字符   Ctrl-L 清空屏幕    </description>
    </item>
    
    <item>
      <title>0005-longest palindromic substring</title>
      <link>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</link>
      <pubDate>Wed, 14 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/14/0005-longest-palindromic-substring/</guid>
      <description>最长回文子串 给定字符串s，找到s中的最长回文子串。
 示例1：
 输入: s = &amp;ldquo;babad&amp;rdquo;
输出: &amp;ldquo;bab&amp;quot;或&amp;quot;aba&amp;rdquo;
 示例2：
 输入: s = &amp;ldquo;cbbd&amp;rdquo;
输出: &amp;ldquo;bb&amp;rdquo;
 示例3：
 输入: s = &amp;ldquo;a&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 示例4：
 输入: s = &amp;ldquo;ac&amp;rdquo;
输出: &amp;ldquo;a&amp;rdquo;
 提示:
 1 &amp;lt;= s.length &amp;lt;= 1000 s仅由数字和英文字母（大写和/或小写）组成   代码 动态规划法 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) # 记录dp过程中发现的最长回文子串 start, stride = 0, 0 # step = 0, 默认为True dp = [[True for j in range(n)] for i in range(n)] # step = 1, 另一种构建块，进行判定 for in in range(n - 1): if s[i] == s[i+1]: start, stride = i, 1 else: dp[i][i+1] = False # step in [2, n-1], 进行判定 for step in range(2, n): for i in range(n - step): if not dp[i + 1][i + step - 1] or s[i] !</description>
    </item>
    
    <item>
      <title>0226-invert-binary-tree</title>
      <link>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0226-invert-binary-tree/</guid>
      <description>题目描述 翻转一棵二叉树。
 示例
 输入:
 4 / \ 2 7 / \ / \ 1 3 6 9  输出:
 4 / \ 7 2 / \ / \ 9 6 3 1    代码 递归 # Definition for a binary tree node # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.</description>
    </item>
    
    <item>
      <title>0234-palindrome linked list</title>
      <link>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/0234-palindrome-linked-list/</guid>
      <description>问题描述 请判断一个链表是否为回文链表
 示例1:
 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1
输出: true
 示例2:
 输入: 1-&amp;gt;2
输出: false
 提示:考虑使用O(n)时间复杂度和O(1)空间复杂度。
 代码 将链表中的元素复制到数组中，借助数组元素的随机访问特性，使用双指针法判定是否为回文链表 # Definition for singly-linked list. # class ListNode: # def __init__(self, val = 0, next = None): # self.val = val # self.next = next class Solution(self, head : ListNode) -&amp;gt; bool: ptr, array = head, list() while ptr: array.append(ptr.val) ptr = ptr.next lptr, rptr = 0, len(array) - 1 while lptr &amp;lt; rptr: if array[lptr] !</description>
    </item>
    
    <item>
      <title>[利用Python进行数据分析] Ch2. Python语法基础 Ipython和Jupyter Notebooks</title>
      <link>https://qidi.ink/post/2021/04/13/python-ch2-python-ipython-jupyter-notebooks/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/python-ch2-python-ipython-jupyter-notebooks/</guid>
      <description>2.1 Python解释器  退出Python解释器返回终端，可输入exit()或Ctrl+D。  2.2 Ipython基础   在IPython中使用%run命令，将执行指定文件，执行结束之后可以与结果进行交互
 如果是在%run一个脚本或一条语句时抛出异常，Ipython默认会打印完整的调用栈，在栈的每个点都会有几行上下文。在发生错误之后，可以使用%debug或%pdb访问栈进行事后调试。    Ipython shell相对于标准Python解释器的进步之一是具备其他IDE和交互计算分析环境所具有的Tab补全功能
  对象的自省:在变量前后使用问号?，可以显示对象的信息。
 对于函数或实例方法，将显示文档字符串。 使用??将会显示函数源码。add_numbers??    在Jupyter notebook中，可以使用%load，将脚本导入到一个代码格中。
  代码运行时按下Ctrl-C，无论是%run或长时间运行命令，都会导致KeyboardInterrupt。这会使几乎所有Pyhton程序立即停止。
  从剪贴板执行程序:如果使用Jupyter notebook，可以将代码复制粘贴到任意代码格执行。在Ipython shell中也可以从剪切板执行。
 %paste可以直接运行剪贴板中的代码。 %cpaste可以粘贴任意多的代码再运行。可以在运行之前查看代码。如果粘贴了错误的代码，可以使用Ctrl-C中断。    IPython有众多键盘快捷键(类似Unix bash Shell)和交互shell的历史命令。
  Jupyter notebook有另一套庞大的快捷键，可参阅Jupyter notebook的帮助文档。
  魔术命令：指令前添加%前缀
 如可以用%timeit%测量Python语句的执行时间。 某些魔术命令有命令行选项，可通过?查看。debug?    2.3 Python语法基础   Python语言设计强调可读性。Python有时被称为可执行的伪代码
  对象作为参数传递给被调函数时，后者的局部变量引用对象，故可以改变可变参数的内容。
  Python变量不固定类型，可引用任意类型对象，此为动态引用。</description>
    </item>
    
    <item>
      <title>Google Chrome Shortcuts</title>
      <link>https://qidi.ink/post/2021/04/13/google-chrome-shortcuts/</link>
      <pubDate>Tue, 13 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/13/google-chrome-shortcuts/</guid>
      <description>cmd + shift + T: 打开上一个关闭的标签页</description>
    </item>
    
    <item>
      <title>0461-hamming distance</title>
      <link>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0461-hamming-distance/</guid>
      <description>问题描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数x和y，计算它们之间的汉明距离。
 示例
 输入: x = 1, y = 4
输出: 2
解释:
1 (0 0 0 1)
4 (0 1 0 0)
 注意: 0 &amp;lt;= x, y &amp;lt; 231
 代码 Brian W. Kernighan &amp;amp; Dennis M. Ritchie class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: cnt += 1 xor &amp;amp;= xor - 1 return cnt Circular shift class Solution: def hammingDistance(self, x, y): xor = x ^ y cnt = 0 while xor: if xor &amp;amp; 1: cnt += 1 return cnt 分析 本问题体现了位运算中关于计1的技巧。</description>
    </item>
    
    <item>
      <title>0543-diameter of binary tree</title>
      <link>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0543-diameter-of-binary-tree/</guid>
      <description>问题描述 给定一棵二叉树，计算它的直径长度。一棵二叉树的直径长度是指任意两个节点路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。
 示例
 输入:
 1 / \ 2 3 / \ 4 5  输出: 3
解释: 路径为[4,2,1,3]或[5,2,1,3]。
 注意:两节点之间的路径长度是以它们之间边的数目表示。
 代码 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.val = val # self.left = left # self.right = right class Solution: def calDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: left_depth, right_depth = self.</description>
    </item>
    
    <item>
      <title>0617-merge two binary trees</title>
      <link>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</link>
      <pubDate>Mon, 12 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/12/0617-merge-two-binary-trees/</guid>
      <description>问题描述 给定两个二叉树，想想当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为NULL的节点将直接作为新二叉树的节点。
 示例
 输入:
 Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7  输出:
 3 / \ 4 5 / \ \ 5 4 7   注意:合并必须从两个树的根节点开始。
 代码 DFS算法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val = 0, left = None, right = None): # self.</description>
    </item>
    
    <item>
      <title>0155-min stack</title>
      <link>https://qidi.ink/post/2021/04/11/0155-min-stack/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0155-min-stack/</guid>
      <description>题目描述 设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。
 push(x): 将元素x推入栈中 pop(): 删除栈顶的元素 top(): 获取栈顶元素 getMin(): 检索栈中的最小元素   示例
 输入:
[&amp;ldquo;MinStack&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;,&amp;ldquo;pop&amp;rdquo;,&amp;ldquo;top&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;]
[[],[-2],[0],[-3],[],[],[],[]]
输出:
[null,null,null,null,-3,null,0,-2]
解释:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -3.
minStack.pop();
minStack.top(); &amp;ndash;&amp;gt; 返回 0.
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -2.
 提示
 pop、top和getMin操作总是在非空栈上调用。   代码 class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here. &amp;#34;&amp;#34;&amp;#34; self.Minstack = [] def push(self, val: int) -&amp;gt; None: if not self.</description>
    </item>
    
    <item>
      <title>0206-reverse linked list</title>
      <link>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0206-reverse-linked-list/</guid>
      <description>问题描述 反转一个简单链表。
 示例:
 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
 提示:
 可以使用递归和迭代两种方式反转链表。
  代码 递归 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head rhead = self.reverseList(head.next) head.next.next, head.next = head, None return rhead 迭代 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.</description>
    </item>
    
    <item>
      <title>0283-move zeroes</title>
      <link>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0283-move-zeroes/</guid>
      <description>问题描述 给定数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。
 示例
 输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
 说明:
   必须在原数组上操作，不能拷贝额外的数组
  尽量减少操作次数
    代码 双指针 - 1 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: count = 0 for num in nums: if num: nums[count] = num count += 1 nums[count:] = [0] * len(nums[count:]) 双指针 - 2 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: i = 0 for j in range(len(nums)): if nums[j]: nums[i], nums[j] = nums[j], nums[i] i += 1 注: 在每一次循环之前，i左边的元素均非零。</description>
    </item>
    
    <item>
      <title>0448-find all numbers disappeared in an array</title>
      <link>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>找到所有数组中消失的数字 给定一个范围在 1 &amp;lt;= a[i] &amp;lt;= n(n = 数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在[1,n]范围之间没有出现在数组中的数字。
考虑不使用额外空间的时间复杂度为O(n)的算法。
 示例
 输入: [4,3,2,7,8,2,3,1]
输出: [5,6]
  代码 O(1)空间复杂度 class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: nums[(num-1) % n] += n for i, num in enumerate(nums): if num &amp;lt;= n: res.append(i+1) return res class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: if nums[abs(num)-1] &amp;gt; 0: nums[abs(num)-1] *= -1 for i, num in enumerate(nums): if num &amp;gt; 0: res.</description>
    </item>
    
    <item>
      <title>《当我真正开始爱自己》</title>
      <link>https://qidi.ink/post/2021/04/11/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/11/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1/</guid>
      <description>当我真正开始爱自己，
我才认识到，所有的痛苦和情感的折磨，
都只是提醒我：活着，不要违背自己的本心。
今天我明白了，这叫做 「真实」
 当我真正开始爱自己，
我才懂得，把自己的愿望强加于人，
是多么的无礼，就算我知道，时机并不成熟，
那人也还没有做好准备，
就算那个人就是我自己，
今天我明白了，这叫做 「尊重」
 当我真正开始爱自己，
我不再渴求不同的人生，
我知道任何发生在我身边的事情，
都是对我成长的邀请。
如今，我称之为 「成熟」
 当我真正开始爱自己，
我才明白，我其实一直都在正确的时间，
正确的地方，发生的一切都恰如其分。
由此我得以平静。
今天我明白了，这叫做 「自信」
 当我真正开始爱自己，
我不再牺牲自己的自由时间，
不再去勾画什么宏伟的明天。
今天我只做有趣和快乐的事，
做自己热爱，让心欢喜的事，
用我的方式，以我的韵律。
今天我明白了，这叫做 「单纯」
 当我真正开始爱自己，
我开始远离一切不健康的东西。
不论是饮食和人物，还是事情和环境，
我远离一切让我远离本真的东西。
从前我把这叫做“追求健康的自私自利”，
但今天我明白了，这是 「自爱」
 当我真正开始爱自己，
我不再总想着要永远正确，
不犯错误。
今天我明白了，这叫做 「谦逊」
 当我真正开始爱自己，
我不再继续沉溺于过去，
也不再为明天而忧虑，
现在我只活在一切正在发生的当下，
今天，我活在此时此地，
如此日复一日。这就叫 「完美」
 当我真正开始爱自己，
我明白，我的思虑让我变得贫乏和病态，
但当我唤起了心灵的力量，
理智就变成了一个重要的伙伴，
这种组合我称之为 「心的智慧」
 我们无须再害怕自己和别人的分歧，
矛盾和问题，
因为即使星星有时也会碰在一起，
形成新的世界，</description>
    </item>
    
    <item>
      <title>0160-intersection of two linked lists</title>
      <link>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0160-intersection-of-two-linked-lists/</guid>
      <description>题目描述 编写一个程序，找到两个单链表相交的起始节点。
 示例1:
 输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出: Reference of the node with value = 8
输入解释: 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。链表A为[4,1,8,4,5]，链表B为[5,0,1,8,4,5]。在A中，相交节点前有2个节点；在B中，相交节点前有3个节点。
 示例2:
 输入: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Refernce of the node with value = 2
输入解释: 相交节点的值为 2 （注意，如果两个链表相交则不能为0）。链表A为[0,9,1,2,4]，链表B为[3,2,4]。在A中，相交节点前有3个节点；在B中，相交节点前有1个节点。
 示例3:
 输入: intersecVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</description>
    </item>
    
    <item>
      <title>0169-majority element</title>
      <link>https://qidi.ink/post/2021/04/10/0169-majority-element/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/10/0169-majority-element/</guid>
      <description>多数元素 给定一个大小为n的数组，找到其中的多数元素。
多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。
可以假设数组是非空的，并且给定的数组总是存在多数元素。
 尝试使用时间复杂度为O(n)，空间复杂度为O(1)的算法解决此问题。   示例1
 输入: [3,2,3]
输出: 3
 示例2
 输入: [2,2,1,1,1,2,2]
输出: 2
  代码 Boyer-Moore 投票法 class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: winner, winner_counter = None, 0 for candidate in nums: if winner_counter == 0: winner = candidate winner_counter += 1 elif winner == candidate: winner_counter += 1 else: winner_counter -= 1 return winner 分析 Boyer-Moore 投票法 Moore投票法旨在解决：如何在任意多的候选人中，定出获得票数最多的候选人。</description>
    </item>
    
    <item>
      <title>0101-symmetric tree</title>
      <link>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0101-symmetric-tree/</guid>
      <description>题目描述 给定一个二叉树，检查它是否是镜像对称的。
 示例1:
 输入:
 1 / \ 2 2 / \ / \ 3 4 4 3  输出: True
 示例2:
 输入:
 1 / \ 2 2 \ \ 3 3    代码: # 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSame(self, lptr:TreeNode, rptr:TreeNode) -&amp;gt; bool: if not lptr and not rptr: return True if not lptr or not rptr or lptr.</description>
    </item>
    
    <item>
      <title>0104-maximum depth of binary tree</title>
      <link>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根结点到最远叶子结点的最长路径上的节点数。
 示例:
给定二叉树[3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7  返回它的最大深度3。
说明: 叶子结点是指没有子节点的节点。
 代码 # 递归，深度优先遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: return 1 + max(self.maxDepth(root.left), self.</description>
    </item>
    
    <item>
      <title>0121-best time to buy and sell stock</title>
      <link>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</guid>
      <description>问题描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。
代码: class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = [0] * len(prices) for i in range(1, len(prices)): profit[i] = max(0, profit[i-1] + prices[i] - prices[i-1]) return max(profit) 分析:  本问题与最大子序和问题相似  </description>
    </item>
    
    <item>
      <title>0136-single nubmer</title>
      <link>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0136-single-nubmer/</guid>
      <description>问题描述  给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
示例1:
 输入: [2,2,1]
输出: 1
 示例2:
 输入: [4,1,2,1,2]
输出: 4
 说明:
考虑线性时间复杂度的原地算法。
 代码 # 异或运算 class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: return reduce(lambda x,y: x^y, nums) 分析 map/reduce:  map()函数接收两个参数，一为函数，一为Iterable。  map()将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。   reduce()函数接收两个参数，一为函数，一为序列。效果为：  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)    示例1:
 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小些的规范名字。
输入[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。
 list(map(lambda x: x.</description>
    </item>
    
    <item>
      <title>0141-linked list cycle</title>
      <link>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/0141-linked-list-cycle/</guid>
      <description>问题描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回true。否则返回false。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: false
解释: 链表中没有环。
 提示:
 链表中节点的数目范围是[0, 104] -105 &amp;lt;= Node.val &amp;lt;= 105 pos 为 -1或者链表中的一个有效索引。   代码 # hashTable # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Git 简介</title>
      <link>https://qidi.ink/post/2021/04/09/git/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/09/git/</guid>
      <description>版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本。版本控制系统可以帮助将选定的文件甚或整个项目回溯到之前某个状态、比较文件的变化细节、查看何时报告了某个功能缺陷。
分布式版本控制系统 在分布式版本控制系统 (Distributed Version Control System) 中，客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。
每一次的克隆操作，实际上都是一次对代码仓库的完整备份。
任何一处协同工作的服务器发生故障，都可以用任何一个镜像出来的本地仓库恢复。
Git 简史 Git诞生于一个极富纷争的年代。
Linux内核开源项目有着为数众多的参与者。1991-2002年间，Linux内核维护工作牵涉到大量提交补丁、保存归档的繁琐事务。2002年，项目组启用分布式版本控制系统BitKeeper来管理和维护代码。2005年，BitKeeper的开发者同Linux内核开源社区合作关系结束，迫使Linux开源社区（特别是Linux的缔造者Linus Torvalds）开发出自己的版本控制系统。他们对新的系统制定了若干目标：
  速度
  简单的设计
  对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
  完全分布式
  有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）
  自2005年诞生以来，Git日臻完善。在高度易用的同时，保留着初期设定的目标。Git速度飞快，及其适合管理大型项目，有着令人难以置信的非线性分支管理系统。
Git 是什么 Git与其他的版本控制系统有颇多相似之处，但在对信息的存储和认知方式上有着很大差异。
直接记录快照，而非差异比较 大部分系统以文件变更列表的方式存储信息，这类系统(常称为基于差异(delta-based)的版本控制)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异。 Git对待数据更像是一个快照流。每当提交更新或保存项目状态时，Git对此时全部文件创建快照并保存快照索引。 近乎所有操作都是本地执行 在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。
Git保证完整性 Git中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着在Git不知情时不能更改任何文件内容或目录内容。
Git用于计算校验和的机制为SHA-1散列，这是一个由40个十六进制字符组成的字符串，基于Git中文件的内容或目录结构计算出来。
Git中众多场景应用这种哈希值。Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
Git一般只添加数据 Git操作几乎只向Git数据库中添加数据。而Git几乎不会执行任何可能导致文件不可恢复的操作，即Git不会从数据库中删除数据。
三种状态 Git有三种状态，文件状态可能处于其中之一：
已修改(modified):修改了文件，但还没保存到数据库中。
已暂存(staged):对一个已修改文件的当前版本做了标记，使其包含在下次提交的快照中。
已提交(committed):数据已经安全地保存在本地数据库中。
相应地，在Git中有三个阶段：工作区、暂存区、Git目录。 工作区:对项目的某个版本独立提取出的内容。
暂存区:保存了下次将要提交的文件信息列表信息。
Git目录:Git用来保存项目的元数据和对象数据库的地方。
基本的Git工作流程如下:
1.在工作区中修改文件。
2.将下次要提交的更改选择性地暂存。
3.提交更新，找到暂存区的文件，将快照永久性地存储到Git目录中。
HELP 使用Git时若需要获取帮助，有三种查阅手册的等价方式：
$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help</description>
    </item>
    
    <item>
      <title>0021-merge two sorted list</title>
      <link>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0021-merge-two-sorted-list/</guid>
      <description>题目描述  将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例1
 输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
 示例2
 输入: l1 = [], l2 = []
输出: []
 示例3
 输入: l1 = [], l2 = [0]
输出: [0]
 提示:
 两个链表的节点数目范围是[0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按非递减顺序排列   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>0053-maximum subarray</title>
      <link>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0053-maximum-subarray/</guid>
      <description>题目描述  给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例1:
 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
 示例2:
 输入: nums = [1]
输出: 1
 示例3:
 输入: nums = [0]
输出: 0
 示例4:
 输入: nums = [-1]
输出: -1
 示例5:
 输入: nums = [-100000]
输出: -100000
 提示:
  1 &amp;lt;= nums.length &amp;lt;= 3 * 104
  -105 &amp;lt;= nums[i] &amp;lt;= 105
   代码 class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i-1] + nums[i]) return max(nums) 分析   考虑nums[i]，若nums[i-1]所存储的累加值为正，则对nums[i]有增益。从而以i结尾的子序和大于nums[i]。</description>
    </item>
    
    <item>
      <title>0070-climbing stairs</title>
      <link>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/08/0070-climbing-stairs/</guid>
      <description>问题描述
假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例1:
 输入: 2
输出: 2
解释: 有两种方法可以到达楼顶。
  1阶 + 1阶
  2阶
   示例2:
 输入: 3
输出: 3
解释:
  1阶 + 1阶 + 1阶
  1阶 + 2阶
  2阶 + 1阶
   注意:
给定n是一个正整数。
 代码 # 递归，超时 class Solution: def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt;= 2: return n else: return self.</description>
    </item>
    
    <item>
      <title>0002-add-two-numbers</title>
      <link>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0002-add-two-numbers/</guid>
      <description>题目描述  给定两个非空的链表，表示两个非负整数。它们的每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。
请你将两个数字相加，并以相同形式返回一个表示和的链表
你可以假设除了数字0之外，这两个数都不会以0开头。
示例1
 输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
 示例2
 输入: l1 = [0], l2 = [0]
输出: [0]
 示例3
 输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
 提示
  每个链表中的节点数在范围[1, 100]内
  0 &amp;lt;= Node.val &amp;lt;= 9
  题目数据保证列表表示的数字不含前导零
   代码 # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>0003-longest substring without repeating characters</title>
      <link>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0003-longest-substring-without-repeating-characters/</guid>
      <description>题目描述  给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
示例1
 输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;abc&amp;quot;，所以其长度为3。
 示例2
 输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是&amp;quot;b&amp;quot;，所以其长度为1。
 示例3
 输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;wke&amp;quot;，所以其长度为3。
 示例4
 输入: s = &amp;quot;&amp;quot;
输出: 0
 提示
  0 &amp;lt;= s.length &amp;lt;= 5 * 104
  s由英文字母、数字、符号和空格组成
   代码 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: #考虑以某一下标为起始位置的最长子串。 l = r = maxlen = 0 hashtable = dict() #记录某一元素出现的最靠结尾的下标 while r in range(len(s)): if s[r] in hashtable and hashtable[s[r]] in range(l, r): l = hashtable[s[r]] + 1 hashtable[s[r]] = r maxlen = max(maxlen, r - l + 1) r += 1 return maxlen 分析  使用滑动窗方法处理子字符串  </description>
    </item>
    
    <item>
      <title>0020-Valid Parentheses</title>
      <link>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/07/0020-valid-parentheses/</guid>
      <description>问题描述  给定一个只包括&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;,&#39;]&#39;的字符串s，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  示例1:
 输入: s = &amp;ldquo;()&amp;rdquo;
输出: true
 示例2:
 输入: s = &amp;ldquo;()[]{}&amp;rdquo;
输出: true
 示例3:
 输入: s = &amp;ldquo;(]&amp;rdquo;
输出: false
 示例4:
 输入: s = &amp;ldquo;([)]&amp;rdquo;
输出: false
 示例5:
 输入: s = &amp;ldquo;{[]}&amp;rdquo;
输出:true
 提示:
  1 &amp;lt;= s.length &amp;lt;= 104
  s仅由括号()[]{}组成
   代码 class Solution: def isValid(self, s: str) -&amp;gt; bool: if len(s) % 2 == 1: return False dictionary = {&amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;} stack = [] for ch in s: if ch in dictionary: stack.</description>
    </item>
    
    <item>
      <title>0001-Two Sum</title>
      <link>https://qidi.ink/post/2021/04/06/0001-two-sum/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/0001-two-sum/</guid>
      <description>题目描述  给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例1
 输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]。
 示例2
 输入: nums = [3,2,4], target = 6
输出: [1,2]
 示例3
 输入: nums = [3,3], target = 6
输出: [0,1]
 提示
  2 &amp;lt;= nums.length &amp;lt;= 103
  只会存在一个有效答案
   代码 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashtable = dict() for i, val in enumerate(nums): if target - val in hashtable: return [hashtable[target - val], i] else: hashtable[val] = i 分析  使用哈希将查找元素的时间复杂度降至O(1)  </description>
    </item>
    
    <item>
      <title>Markdown Grammer</title>
      <link>https://qidi.ink/post/2021/04/06/markdown-grammer/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/markdown-grammer/</guid>
      <description>HTML 上标: Bull&amp;lt;sup&amp;gt;TM&amp;lt;/sup&amp;gt; BullTM
下标: H&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;O H2O
表格 markdown制作表格，使用|分隔不同单元格，-分隔表头和其他行。
语法格式为：
 | 表头 | 表头 |
| ---- | ---- |
| 单元 | 单元 |
| 单元 | 单元 |
 可以设置表格的对齐方式：
 -:设置单元格内容和标题栏居右对齐 :-设置单元格内容和标题栏居左对齐 :-:设置单元格内容和标题栏居中对齐  </description>
    </item>
    
    <item>
      <title>VIM Shorcuts</title>
      <link>https://qidi.ink/post/2021/04/06/vim-shorcuts/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/vim-shorcuts/</guid>
      <description>跳转命令 shift + g: 跳转到文件结尾
gg: 跳转到文件开头
:10: 跳转到第10行
删除命令 :1,10d: VIM模式下删除1～10行的内容
选中命令 v+j/k/h/l: 进入VISUAL模式，文本选中。
对于选中的文本可执行以下操作：
d: 剪切
y: 复制
p: 粘贴
0: 选中当前行，光标位置到行首
$: 选中当前行，光标位置到行尾
撤销与恢复 u: 撤销上一次操作
:redo: 恢复</description>
    </item>
    
    <item>
      <title>基于Hugo和Github Pages的个人博客搭建过程</title>
      <link>https://qidi.ink/post/2021/04/06/hugo-github-pages/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/hugo-github-pages/</guid>
      <description>撰写博文 使用RStudio IDE
blogdown::serve_site()命令，提供个人网站的本地实时渲染
blogdown::hugo_build()命令，在push给Github远程仓库之前，编译文件
可以在Vim中使用markdown语法对文本进行编辑</description>
    </item>
    
    <item>
      <title>用Parallels Desktop搭建Ubuntu 20.04虚拟机</title>
      <link>https://qidi.ink/post/2021/04/06/macos-vmware-ubuntu/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/post/2021/04/06/macos-vmware-ubuntu/</guid>
      <description>配置虚拟机使用宿主机VPN 环境介绍 - macOS Big Sur: 11.0.1 - ShadowsocksX-NG: 1.4.1-R8 - Parallels Desktop: 16.5.0 - Ubuntu: 20.04 配置过程  修改ShadowsocksX-NG http 代理端口  HTTP Proxy Preferences中：
 设置HTTP Proxy Listen Address为0.0.0.0 设置HTTP Proxy Listen Port为1087  测试通过局域网是否能访问(可选)   通过lsof查看是否能够在0.0.0.0:1087端口工作。  $ lsof -sTCP:LISTEN -n -P|grep 1087 若显示*:1087说明服务正常。
查看虚拟机局域网ip  在虚拟机中使用ifconfig命令查看局域网ip(以192、172、10开头)并记录。
找到主机的局域网ip  在主机上找出与虚拟机同网段的ip地址，记为IP。此ip地址和虚拟机ip地址的前三段相同。
虚拟机export代理配置  在.bashrc、.zshrc、.profile文件中，指定代理地址。
export http_proxy=http://IP:1087 export https_proxy=http://IP:1087 修改虚拟机中的Settings  打开Settings-Network-VPN-Network Proxy-Manual。
设置HTTP Proxy和HTTPS Proxy中的地址和端口分别为IP和1087。
参考链接 Mac下虚拟机如何使用主机的shadowsockets科学上网</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>https://qidi.ink/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://qidi.ink/about/</guid>
      <description>喜欢 心理学 友情链接 StriveZs的博客</description>
    </item>
    
  </channel>
</rss>
