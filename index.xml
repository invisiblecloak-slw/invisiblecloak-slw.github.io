<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on XIU</title>
    <link>/</link>
    <description>Recent content in Home on XIU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 09 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0101-symmetric tree</title>
      <link>/post/2021/04/09/0101-symmetric-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0101-symmetric-tree/</guid>
      <description>题目描述 给定一个二叉树，检查它是否是镜像对称的。
 示例1:
 输入:
 1 / \ 2 2 / \ / \ 3 4 4 3  输出: True
 示例2:
 输入:
 1 / \ 2 2 \ \ 3 3    代码: # 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSame(self, lptr:TreeNode, rptr:TreeNode) -&amp;gt; bool: if not lptr and not rptr: return True if not lptr or not rptr or lptr.</description>
    </item>
    
    <item>
      <title>0104-maximum depth of binary tree</title>
      <link>/post/2021/04/09/0104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根结点到最远叶子结点的最长路径上的节点数。
 示例:
给定二叉树[3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7  返回它的最大深度3。
说明: 叶子结点是指没有子节点的节点。
 代码 # 递归，深度优先遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: return 1 + max(self.maxDepth(root.left), self.</description>
    </item>
    
    <item>
      <title>0121-best time to buy and sell stock</title>
      <link>/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</guid>
      <description>问题描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。
代码: class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = [0] * len(prices) for i in range(1, len(prices)): profit[i] = max(0, profit[i-1] + prices[i] - prices[i-1]) return max(profit) 分析:  本问题与最大子序和问题相似  </description>
    </item>
    
    <item>
      <title>0021-merge two sorted list</title>
      <link>/post/2021/04/08/0021-merge-two-sorted-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/08/0021-merge-two-sorted-list/</guid>
      <description>题目描述  将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例1
 输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
 示例2
 输入: l1 = [], l2 = []
输出: []
 示例3
 输入: l1 = [], l2 = [0]
输出: [0]
 提示:
 两个链表的节点数目范围是[0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按非递减顺序排列   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>0053-maximum subarray</title>
      <link>/post/2021/04/08/0053-maximum-subarray/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/08/0053-maximum-subarray/</guid>
      <description>题目描述  给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例1:
 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
 示例2:
 输入: nums = [1]
输出: 1
 示例3:
 输入: nums = [0]
输出: 0
 示例4:
 输入: nums = [-1]
输出: -1
 示例5:
 输入: nums = [-100000]
输出: -100000
 提示:
  1 &amp;lt;= nums.length &amp;lt;= 3 * 104
  -105 &amp;lt;= nums[i] &amp;lt;= 105
   代码 class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i-1] + nums[i]) return max(nums) 分析 考虑nums[i]，若nums[i-1]所存储的累加值为正，则对nums[i]有增益。从而以i结尾的子序和大于nums[i]。</description>
    </item>
    
    <item>
      <title>0070-climbing stairs</title>
      <link>/post/2021/04/08/0070-climbing-stairs/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/08/0070-climbing-stairs/</guid>
      <description>问题描述
假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例1:
 输入: 2
输出: 2
解释: 有两种方法可以到达楼顶。
  1阶 + 1阶
  2阶
   示例2:
 输入: 3
输出: 3
解释:
  1阶 + 1阶 + 1阶
  1阶 + 2阶
  2阶 + 1阶
   注意:
给定n是一个正整数。
 代码 # 递归，超时 class Solution: def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt;= 2: return n else: return self.</description>
    </item>
    
    <item>
      <title>0002-add-two-numbers</title>
      <link>/post/2021/04/07/0002-add-two-numbers/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/07/0002-add-two-numbers/</guid>
      <description>题目描述  给定两个非空的链表，表示两个非负整数。它们的每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。
请你将两个数字相加，并以相同形式返回一个表示和的链表
你可以假设除了数字0之外，这两个数都不会以0开头。
示例1
 输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
 示例2
 输入: l1 = [0], l2 = [0]
输出: [0]
 示例3
 输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
 提示
  每个链表中的节点数在范围[1, 100]内
  0 &amp;lt;= Node.val &amp;lt;= 9
  题目数据保证列表表示的数字不含前导零
   代码 # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>0003-longest substring without repeating characters</title>
      <link>/post/2021/04/07/0003-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/07/0003-longest-substring-without-repeating-characters/</guid>
      <description>题目描述  给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
示例1
 输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;abc&amp;quot;，所以其长度为3。
 示例2
 输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是&amp;quot;b&amp;quot;，所以其长度为1。
 示例3
 输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;wke&amp;quot;，所以其长度为3。
 示例4
 输入: s = &amp;quot;&amp;quot;
输出: 0
 提示
  0 &amp;lt;= s.length &amp;lt;= 5 * 104
  s由英文字母、数字、符号和空格组成
   代码 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: #考虑以某一下标为起始位置的最长子串。 l = r = maxlen = 0 hashtable = dict() #记录某一元素出现的最靠结尾的下标 while r in range(len(s)): if s[r] in hashtable and hashtable[s[r]] in range(l, r): l = hashtable[s[r]] + 1 hashtable[s[r]] = r maxlen = max(maxlen, r - l + 1) r += 1 return maxlen 分析 使用滑动窗方法处理子字符串</description>
    </item>
    
    <item>
      <title>0020-Valid Parentheses</title>
      <link>/post/2021/04/07/0020-valid-parentheses/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/07/0020-valid-parentheses/</guid>
      <description>问题描述  给定一个只包括&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;,&#39;]&#39;的字符串s，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  示例1:
 输入: s = &amp;ldquo;()&amp;rdquo;
输出: true
 示例2:
 输入: s = &amp;ldquo;()[]{}&amp;rdquo;
输出: true
 示例3:
 输入: s = &amp;ldquo;(]&amp;rdquo;
输出: false
 示例4:
 输入: s = &amp;ldquo;([)]&amp;rdquo;
输出: false
 示例5:
 输入: s = &amp;ldquo;{[]}&amp;rdquo;
输出:true
 提示:
  1 &amp;lt;= s.length &amp;lt;= 104
  s仅由括号()[]{}组成
   代码 class Solution: def isValid(self, s: str) -&amp;gt; bool: if len(s) % 2 == 1: return False dictionary = {&amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;} stack = [] for ch in s: if ch in dictionary: stack.</description>
    </item>
    
    <item>
      <title>0001-Two Sum</title>
      <link>/post/2021/04/06/0001-two-sum/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/0001-two-sum/</guid>
      <description>题目描述  给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例1
 输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]。
 示例2
 输入: nums = [3,2,4], target = 6
输出: [1,2]
 示例3
 输入: nums = [3,3], target = 6
输出: [0,1]
 提示
  2 &amp;lt;= nums.length &amp;lt;= 103
  只会存在一个有效答案
   代码 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashtable = dict() for i, val in enumerate(nums): if target - val in hashtable: return [hashtable[target - val], i] else: hashtable[val] = i 分析  使用哈希将查找元素的时间复杂度降至O(1)  </description>
    </item>
    
    <item>
      <title>Mac下使用VMware创建Ubuntu虚拟机</title>
      <link>/post/2021/04/06/macos-vmware-ubuntu/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/macos-vmware-ubuntu/</guid>
      <description>配置Ubuntu虚拟机使用宿主机VPN 环境介绍 macOS Big Sur: 11.0.1
ShadowsocksX-NG:
VMware Fusion:
Ubuntu:
step1:修改ShadowsocksX-NG http 代理端口 step2:测试通过局域网是否能访问(可选) step3:查看虚拟机局域网ip step4:找到主机的局域网ip step5:虚拟机export代理配置 使用export命令只对当前的terminal session有效，如果想全部流量都走Shadowsocks出去，需要将export命令写到.bashrc、.zshrc、.profile文件中。
参考链接 Mac下虚拟机如何使用主机的shadowsockets科学上网
VMware虚拟机（Ubuntu）通过主机代理实现翻墙（shadowsocks）</description>
    </item>
    
    <item>
      <title>Markdown Grammer</title>
      <link>/post/2021/04/06/markdown-grammer/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/markdown-grammer/</guid>
      <description>HTML 上标: Bull&amp;lt;sup&amp;gt;TM&amp;lt;/sup&amp;gt; BullTM
下标: H&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;O H2O</description>
    </item>
    
    <item>
      <title>VIM Shorcuts</title>
      <link>/post/2021/04/06/vim-shorcuts/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/vim-shorcuts/</guid>
      <description>跳转命令 shift + g: 跳转到文件结尾 :10: 跳转到第10行
删除命令 :1,10d: VIM模式下删除1～10行的内容
选中命令 v+j/k/h/l: 进入VISUAL模式，文本选中。
对于选中的文本可执行以下操作：
d: 剪切
y: 复制
p: 粘贴
0: 选中当前行，光标位置到行首
$: 选中当前行，光标位置到行尾</description>
    </item>
    
    <item>
      <title>基于Hugo和Github Pages的个人博客搭建过程</title>
      <link>/post/2021/04/06/hugo-github-pages/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/hugo-github-pages/</guid>
      <description>撰写博文 使用RStudio IDE
blogdown::serve_site()命令，提供个人网站的本地实时渲染
blogdown::hugo_build()命令，在push给Github远程仓库之前，编译文件
可以在Vim中使用markdown语法对文本进行编辑</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>喜欢 心理学 友情链接 StriveZs的博客</description>
    </item>
    
  </channel>
</rss>
