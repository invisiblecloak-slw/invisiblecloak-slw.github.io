<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on XIU</title>
    <link>/</link>
    <description>Recent content in Home on XIU</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 11 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>0155-min stack</title>
      <link>/post/2021/04/11/0155-min-stack/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/11/0155-min-stack/</guid>
      <description>题目描述 设计一个支持push,pop,top操作，并能在常数时间内检索到最小元素的栈。
 push(x): 将元素x推入栈中 pop(): 删除栈顶的元素 top(): 获取栈顶元素 getMin(): 检索栈中的最小元素   示例
 输入:
[&amp;ldquo;MinStack&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;push&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;,&amp;ldquo;pop&amp;rdquo;,&amp;ldquo;top&amp;rdquo;,&amp;ldquo;getMin&amp;rdquo;]
[[],[-2],[0],[-3],[],[],[],[]]
输出:
[null,null,null,null,-3,null,0,-2]
解释:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -3.
minStack.pop();
minStack.top(); &amp;ndash;&amp;gt; 返回 0.
minStack.getMin(); &amp;ndash;&amp;gt; 返回 -2.
 提示
 pop、top和getMin操作总是在非空栈上调用。   代码 class MinStack: def __init__(self): &amp;#34;&amp;#34;&amp;#34; initialize your data structure here. &amp;#34;&amp;#34;&amp;#34; self.Minstack = [] def push(self, val: int) -&amp;gt; None: if not self.</description>
    </item>
    
    <item>
      <title>0206-reverse linked list</title>
      <link>/post/2021/04/11/0206-reverse-linked-list/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/11/0206-reverse-linked-list/</guid>
      <description>问题描述 反转一个简单链表。
 示例:
 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
 提示:
 可以使用递归和迭代两种方式反转链表。
  代码 递归 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def reverseList(self, head: ListNode) -&amp;gt; ListNode: if not head or not head.next: return head rhead = self.reverseList(head.next) head.next.next, head.next = head, None return rhead 迭代 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.</description>
    </item>
    
    <item>
      <title>0283-move zeroes</title>
      <link>/post/2021/04/11/0283-move-zeroes/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/11/0283-move-zeroes/</guid>
      <description>问题描述 给定数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。
 示例
 输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
 说明:
   必须在原数组上操作，不能拷贝额外的数组
  尽量减少操作次数
    代码 双指针 - 1 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: count = 0 for num in nums: if num: nums[count] = num count += 1 nums[count:] = [0] * len(nums[count:]) 双指针 - 2 class Solution: def moveZeroes(self, nums: List[int]) -&amp;gt; None: i = 0 for j in range(len(nums)): if nums[j]: nums[i], nums[j] = nums[j], nums[i] i += 1 注: 在每一次循环之前，i左边的元素均非零。</description>
    </item>
    
    <item>
      <title>0448-find all numbers disappeared in an array</title>
      <link>/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/11/0448-find-all-numbers-disappeared-in-an-array/</guid>
      <description>找到所有数组中消失的数字 给定一个范围在 1 &amp;lt;= a[i] &amp;lt;= n(n = 数组大小)的整型数组，数组中的元素一些出现了两次，另一些只出现一次。
找到所有在[1,n]范围之间没有出现在数组中的数字。
考虑不使用额外空间的时间复杂度为O(n)的算法。
 示例
 输入: [4,3,2,7,8,2,3,1]
输出: [5,6]
  代码 O(1)空间复杂度 class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: nums[(num-1) % n] += n for i, num in enumerate(nums): if num &amp;lt;= n: res.append(i+1) return res class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: res = [] n = len(nums) for num in nums: if nums[abs(num)-1] &amp;gt; 0: nums[abs(num)-1] *= -1 for i, num in enumerate(nums): if num &amp;gt; 0: res.</description>
    </item>
    
    <item>
      <title>《当我真正开始爱自己》</title>
      <link>/post/2021/04/11/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1/</link>
      <pubDate>Sun, 11 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/11/%E5%BD%93%E6%88%91%E7%9C%9F%E6%AD%A3%E5%BC%80%E5%A7%8B%E7%88%B1%E8%87%AA%E5%B7%B1/</guid>
      <description>当我真正开始爱自己，
我才认识到，所有的痛苦和情感的折磨，
都只是提醒我：活着，不要违背自己的本心。
今天我明白了，这叫做 「真实」
 当我真正开始爱自己，
我才懂得，把自己的愿望强加于人，
是多么的无礼，就算我知道，时机并不成熟，
那人也还没有做好准备，
就算那个人就是我自己，
今天我明白了，这叫做 「尊重」
 当我真正开始爱自己，
我不再渴求不同的人生，
我知道任何发生在我身边的事情，
都是对我成长的邀请。
如今，我称之为 「成熟」
 当我真正开始爱自己，
我才明白，我其实一直都在正确的时间，
正确的地方，发生的一切都恰如其分。
由此我得以平静。
今天我明白了，这叫做 「自信」
 当我真正开始爱自己，
我不再牺牲自己的自由时间，
不再去勾画什么宏伟的明天。
今天我只做有趣和快乐的事，
做自己热爱，让心欢喜的事，
用我的方式，以我的韵律。
今天我明白了，这叫做 「单纯」
 当我真正开始爱自己，
我开始远离一切不健康的东西。
不论是饮食和人物，还是事情和环境，
我远离一切让我远离本真的东西。
从前我把这叫做“追求健康的自私自利”，
但今天我明白了，这是 「自爱」
 当我真正开始爱自己，
我不再总想着要永远正确，
不犯错误。
今天我明白了，这叫做 「谦逊」
 当我真正开始爱自己，
我不再继续沉溺于过去，
也不再为明天而忧虑，
现在我只活在一切正在发生的当下，
今天，我活在此时此地，
如此日复一日。这就叫 「完美」
 当我真正开始爱自己，
我明白，我的思虑让我变得贫乏和病态，
但当我唤起了心灵的力量，
理智就变成了一个重要的伙伴，
这种组合我称之为 「心的智慧」
 我们无须再害怕自己和别人的分歧，
矛盾和问题，
因为即使星星有时也会碰在一起，
形成新的世界，</description>
    </item>
    
    <item>
      <title>0160-intersection of two linked lists</title>
      <link>/post/2021/04/10/0160-intersection-of-two-linked-lists/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/10/0160-intersection-of-two-linked-lists/</guid>
      <description>题目描述 编写一个程序，找到两个单链表相交的起始节点。
 示例1:
 输入: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出: Reference of the node with value = 8
输入解释: 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。链表A为[4,1,8,4,5]，链表B为[5,0,1,8,4,5]。在A中，相交节点前有2个节点；在B中，相交节点前有3个节点。
 示例2:
 输入: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出: Refernce of the node with value = 2
输入解释: 相交节点的值为 2 （注意，如果两个链表相交则不能为0）。链表A为[0,9,1,2,4]，链表B为[3,2,4]。在A中，相交节点前有3个节点；在B中，相交节点前有1个节点。
 示例3:
 输入: intersecVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</description>
    </item>
    
    <item>
      <title>0169-majority element</title>
      <link>/post/2021/04/10/0169-majority-element/</link>
      <pubDate>Sat, 10 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/10/0169-majority-element/</guid>
      <description>多数元素 给定一个大小为n的数组，找到其中的多数元素。
多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素。
可以假设数组是非空的，并且给定的数组总是存在多数元素。
 尝试使用时间复杂度为O(n)，空间复杂度为O(1)的算法解决此问题。   示例1
 输入: [3,2,3]
输出: 3
 示例2
 输入: [2,2,1,1,1,2,2]
输出: 2
  代码 Boyer-Moore 投票法 class Solution: def majorityElement(self, nums: List[int]) -&amp;gt; int: winner, winner_counter = None, 0 for candidate in nums: if winner_counter == 0: winner = candidate winner_counter += 1 elif winner == candidate: winner_counter += 1 else: winner_counter -= 1 return winner 分析 Boyer-Moore 投票法 Moore投票法旨在解决：如何在任意多的候选人中，定出获得票数最多的候选人。</description>
    </item>
    
    <item>
      <title>0101-symmetric tree</title>
      <link>/post/2021/04/09/0101-symmetric-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0101-symmetric-tree/</guid>
      <description>题目描述 给定一个二叉树，检查它是否是镜像对称的。
 示例1:
 输入:
 1 / \ 2 2 / \ / \ 3 4 4 3  输出: True
 示例2:
 输入:
 1 / \ 2 2 \ \ 3 3    代码: # 递归 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isSame(self, lptr:TreeNode, rptr:TreeNode) -&amp;gt; bool: if not lptr and not rptr: return True if not lptr or not rptr or lptr.</description>
    </item>
    
    <item>
      <title>0104-maximum depth of binary tree</title>
      <link>/post/2021/04/09/0104-maximum-depth-of-binary-tree/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0104-maximum-depth-of-binary-tree/</guid>
      <description>题目描述 给定一个二叉树，找出其最大深度。
二叉树的深度为根结点到最远叶子结点的最长路径上的节点数。
 示例:
给定二叉树[3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7  返回它的最大深度3。
说明: 叶子结点是指没有子节点的节点。
 代码 # 递归，深度优先遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 else: return 1 + max(self.maxDepth(root.left), self.</description>
    </item>
    
    <item>
      <title>0121-best time to buy and sell stock</title>
      <link>/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0121-best-time-to-buy-and-sell-stock/</guid>
      <description>问题描述 给定一个数组prices，它的第i个元素prices[i]表示一支给定股票第i天的价格。
你只能选择某一天买入这只股票，并选择在未来的某一个不同的日子卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回0。
代码: class Solution: def maxProfit(self, prices: List[int]) -&amp;gt; int: profit = [0] * len(prices) for i in range(1, len(prices)): profit[i] = max(0, profit[i-1] + prices[i] - prices[i-1]) return max(profit) 分析:  本问题与最大子序和问题相似  </description>
    </item>
    
    <item>
      <title>0136-single nubmer</title>
      <link>/post/2021/04/09/0136-single-nubmer/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0136-single-nubmer/</guid>
      <description>问题描述  给定一个非空整数数组，除了某个元素只出现一次之外，其余每个元素均出现两次。找出那个只出现了一次的元素。
示例1:
 输入: [2,2,1]
输出: 1
 示例2:
 输入: [4,1,2,1,2]
输出: 4
 说明:
考虑线性时间复杂度的原地算法。
 代码 # 异或运算 class Solution: def singleNumber(self, nums: List[int]) -&amp;gt; int: return reduce(lambda x,y: x^y, nums) 分析 map/reduce:  map()函数接收两个参数，一为函数，一为Iterable。  map()将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。   reduce()函数接收两个参数，一为函数，一为序列。效果为：  reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)    示例1:
 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小些的规范名字。
输入[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]。
 list(map(lambda x: x.</description>
    </item>
    
    <item>
      <title>0141-linked list cycle</title>
      <link>/post/2021/04/09/0141-linked-list-cycle/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/0141-linked-list-cycle/</guid>
      <description>问题描述 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪next指针再次到达，则链表中存在环。为了表示给定链表中的环，我们使用整数pos来表示链表尾连接到链表中的位置（索引从0开始）。如果pos是-1，则在该链表中没有环。注意：pos不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回true。否则返回false。
 示例1:
 输入: head = [3,2,0,-4], pos = 1
输出: true
解释: 链表中有一个环，其尾部连接到第二个节点。
 示例2:
 输入: head = [1,2], pos = 0
输出: true
解释: 链表中有一个环，其尾部连接到第一个节点。
 示例3:
 输入: head = [1], pos = -1
输出: false
解释: 链表中没有环。
 提示:
 链表中节点的数目范围是[0, 104] -105 &amp;lt;= Node.val &amp;lt;= 105 pos 为 -1或者链表中的一个有效索引。   代码 # hashTable # Definition for singly-linked list. # class ListNode: # def __init__(self, x): # self.</description>
    </item>
    
    <item>
      <title>Git 简介</title>
      <link>/post/2021/04/09/git/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/09/git/</guid>
      <description>版本控制 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。
图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本。版本控制系统可以帮助将选定的文件甚或整个项目回溯到之前某个状态、比较文件的变化细节、查看何时报告了某个功能缺陷。
分布式版本控制系统 在分布式版本控制系统 (Distributed Version Control System) 中，客户端不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。
每一次的克隆操作，实际上都是一次对代码仓库的完整备份。
任何一处协同工作的服务器发生故障，都可以用任何一个镜像出来的本地仓库恢复。
Git 简史 Git诞生于一个极富纷争的年代。
Linux内核开源项目有着为数众多的参与者。1991-2002年间，Linux内核维护工作牵涉到大量提交补丁、保存归档的繁琐事务。2002年，项目组启用分布式版本控制系统BitKeeper来管理和维护代码。2005年，BitKeeper的开发者同Linux内核开源社区合作关系结束，迫使Linux开源社区（特别是Linux的缔造者Linus Torvalds）开发出自己的版本控制系统。他们对新的系统制定了若干目标：
  速度
  简单的设计
  对非线性开发模式的强力支持（允许成千上万个并行开发的分支）
  完全分布式
  有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）
  自2005年诞生以来，Git日臻完善。在高度易用的同时，保留着初期设定的目标。Git速度飞快，及其适合管理大型项目，有着令人难以置信的非线性分支管理系统。
Git 是什么 Git与其他的版本控制系统有颇多相似之处，但在对信息的存储和认知方式上有着很大差异。
直接记录快照，而非差异比较 大部分系统以文件变更列表的方式存储信息，这类系统(常称为基于差异(delta-based)的版本控制)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异。 Git对待数据更像是一个快照流。每当提交更新或保存项目状态时，Git对此时全部文件创建快照并保存快照索引。 近乎所有操作都是本地执行 在Git中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。
Git保证完整性 Git中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着在Git不知情时不能更改任何文件内容或目录内容。
Git用于计算校验和的机制为SHA-1散列，这是一个由40个十六进制字符组成的字符串，基于Git中文件的内容或目录结构计算出来。
Git中众多场景应用这种哈希值。Git数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
Git一般只添加数据 Git操作几乎只向Git数据库中添加数据。而Git几乎不会执行任何可能导致文件不可恢复的操作，即Git不会从数据库中删除数据。
三种状态 Git有三种状态，文件状态可能处于其中之一：
已修改(modified):修改了文件，但还没保存到数据库中。
已暂存(staged):对一个已修改文件的当前版本做了标记，使其包含在下次提交的快照中。
已提交(committed):数据已经安全地保存在本地数据库中。
相应地，在Git中有三个阶段：工作区、暂存区、Git目录。 工作区:对项目的某个版本独立提取出的内容。
暂存区:保存了下次将要提交的文件信息列表信息。
Git目录:Git用来保存项目的元数据和对象数据库的地方。
基本的Git工作流程如下:
1.在工作区中修改文件。
2.将下次要提交的更改选择性地暂存。
3.提交更新，找到暂存区的文件，将快照永久性地存储到Git目录中。
HELP 使用Git时若需要获取帮助，有三种查阅手册的等价方式：
$ git help &amp;lt;verb&amp;gt;
$ git &amp;lt;verb&amp;gt; --help</description>
    </item>
    
    <item>
      <title>0021-merge two sorted list</title>
      <link>/post/2021/04/08/0021-merge-two-sorted-list/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/08/0021-merge-two-sorted-list/</guid>
      <description>题目描述  将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
示例1
 输入: l1 = [1,2,4], l2 = [1,3,4]
输出: [1,1,2,3,4,4]
 示例2
 输入: l1 = [], l2 = []
输出: []
 示例3
 输入: l1 = [], l2 = [0]
输出: [0]
 提示:
 两个链表的节点数目范围是[0, 50] -100 &amp;lt;= Node.val &amp;lt;= 100 l1 和 l2 均按非递减顺序排列   代码 # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.</description>
    </item>
    
    <item>
      <title>0053-maximum subarray</title>
      <link>/post/2021/04/08/0053-maximum-subarray/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/08/0053-maximum-subarray/</guid>
      <description>题目描述  给定一个整数数组nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例1:
 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1]的和最大，为6。
 示例2:
 输入: nums = [1]
输出: 1
 示例3:
 输入: nums = [0]
输出: 0
 示例4:
 输入: nums = [-1]
输出: -1
 示例5:
 输入: nums = [-100000]
输出: -100000
 提示:
  1 &amp;lt;= nums.length &amp;lt;= 3 * 104
  -105 &amp;lt;= nums[i] &amp;lt;= 105
   代码 class Solution: def maxSubArray(self, nums: List[int]) -&amp;gt; int: for i in range(1, len(nums)): nums[i] = max(nums[i], nums[i-1] + nums[i]) return max(nums) 分析   考虑nums[i]，若nums[i-1]所存储的累加值为正，则对nums[i]有增益。从而以i结尾的子序和大于nums[i]。</description>
    </item>
    
    <item>
      <title>0070-climbing stairs</title>
      <link>/post/2021/04/08/0070-climbing-stairs/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/08/0070-climbing-stairs/</guid>
      <description>问题描述
假设你正在爬楼梯。需要n阶你才能到达楼顶。
每次你可以爬1或2个台阶。你有多少种不同的方法可以爬到楼顶呢？
示例1:
 输入: 2
输出: 2
解释: 有两种方法可以到达楼顶。
  1阶 + 1阶
  2阶
   示例2:
 输入: 3
输出: 3
解释:
  1阶 + 1阶 + 1阶
  1阶 + 2阶
  2阶 + 1阶
   注意:
给定n是一个正整数。
 代码 # 递归，超时 class Solution: def climbStairs(self, n: int) -&amp;gt; int: if n &amp;lt;= 2: return n else: return self.</description>
    </item>
    
    <item>
      <title>0002-add-two-numbers</title>
      <link>/post/2021/04/07/0002-add-two-numbers/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/07/0002-add-two-numbers/</guid>
      <description>题目描述  给定两个非空的链表，表示两个非负整数。它们的每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。
请你将两个数字相加，并以相同形式返回一个表示和的链表
你可以假设除了数字0之外，这两个数都不会以0开头。
示例1
 输入: l1 = [2,4,3], l2 = [5,6,4]
输出: [7,0,8]
解释: 342 + 465 = 807
 示例2
 输入: l1 = [0], l2 = [0]
输出: [0]
 示例3
 输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出: [8,9,9,9,0,0,0,1]
 提示
  每个链表中的节点数在范围[1, 100]内
  0 &amp;lt;= Node.val &amp;lt;= 9
  题目数据保证列表表示的数字不含前导零
   代码 # Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>0003-longest substring without repeating characters</title>
      <link>/post/2021/04/07/0003-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/07/0003-longest-substring-without-repeating-characters/</guid>
      <description>题目描述  给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。
示例1
 输入: s = &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;abc&amp;quot;，所以其长度为3。
 示例2
 输入: s = &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是&amp;quot;b&amp;quot;，所以其长度为1。
 示例3
 输入: s = &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是&amp;quot;wke&amp;quot;，所以其长度为3。
 示例4
 输入: s = &amp;quot;&amp;quot;
输出: 0
 提示
  0 &amp;lt;= s.length &amp;lt;= 5 * 104
  s由英文字母、数字、符号和空格组成
   代码 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: #考虑以某一下标为起始位置的最长子串。 l = r = maxlen = 0 hashtable = dict() #记录某一元素出现的最靠结尾的下标 while r in range(len(s)): if s[r] in hashtable and hashtable[s[r]] in range(l, r): l = hashtable[s[r]] + 1 hashtable[s[r]] = r maxlen = max(maxlen, r - l + 1) r += 1 return maxlen 分析  使用滑动窗方法处理子字符串  </description>
    </item>
    
    <item>
      <title>0020-Valid Parentheses</title>
      <link>/post/2021/04/07/0020-valid-parentheses/</link>
      <pubDate>Wed, 07 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/07/0020-valid-parentheses/</guid>
      <description>问题描述  给定一个只包括&#39;(&#39;,&#39;)&#39;,&#39;{&#39;,&#39;}&#39;,&#39;[&#39;,&#39;]&#39;的字符串s，判断字符串是否有效。
有效字符串需满足：
 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。  示例1:
 输入: s = &amp;ldquo;()&amp;rdquo;
输出: true
 示例2:
 输入: s = &amp;ldquo;()[]{}&amp;rdquo;
输出: true
 示例3:
 输入: s = &amp;ldquo;(]&amp;rdquo;
输出: false
 示例4:
 输入: s = &amp;ldquo;([)]&amp;rdquo;
输出: false
 示例5:
 输入: s = &amp;ldquo;{[]}&amp;rdquo;
输出:true
 提示:
  1 &amp;lt;= s.length &amp;lt;= 104
  s仅由括号()[]{}组成
   代码 class Solution: def isValid(self, s: str) -&amp;gt; bool: if len(s) % 2 == 1: return False dictionary = {&amp;#39;(&amp;#39;:&amp;#39;)&amp;#39;, &amp;#39;{&amp;#39;:&amp;#39;}&amp;#39;, &amp;#39;[&amp;#39;:&amp;#39;]&amp;#39;} stack = [] for ch in s: if ch in dictionary: stack.</description>
    </item>
    
    <item>
      <title>0001-Two Sum</title>
      <link>/post/2021/04/06/0001-two-sum/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/0001-two-sum/</guid>
      <description>题目描述  给定一个整数数组nums和一个整数目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例1
 输入: nums = [2,7,11,15], target = 9
输出: [0,1]
解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]。
 示例2
 输入: nums = [3,2,4], target = 6
输出: [1,2]
 示例3
 输入: nums = [3,3], target = 6
输出: [0,1]
 提示
  2 &amp;lt;= nums.length &amp;lt;= 103
  只会存在一个有效答案
   代码 class Solution: def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]: hashtable = dict() for i, val in enumerate(nums): if target - val in hashtable: return [hashtable[target - val], i] else: hashtable[val] = i 分析  使用哈希将查找元素的时间复杂度降至O(1)  </description>
    </item>
    
    <item>
      <title>Mac下使用VMware创建Ubuntu虚拟机</title>
      <link>/post/2021/04/06/macos-vmware-ubuntu/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/macos-vmware-ubuntu/</guid>
      <description>配置Ubuntu虚拟机使用宿主机VPN 环境介绍 macOS Big Sur: 11.0.1
ShadowsocksX-NG:
VMware Fusion:
Ubuntu:
step1:修改ShadowsocksX-NG http 代理端口 step2:测试通过局域网是否能访问(可选) step3:查看虚拟机局域网ip step4:找到主机的局域网ip step5:虚拟机export代理配置 使用export命令只对当前的terminal session有效，如果想全部流量都走Shadowsocks出去，需要将export命令写到.bashrc、.zshrc、.profile文件中。
参考链接 Mac下虚拟机如何使用主机的shadowsockets科学上网
VMware虚拟机（Ubuntu）通过主机代理实现翻墙（shadowsocks）</description>
    </item>
    
    <item>
      <title>Markdown Grammer</title>
      <link>/post/2021/04/06/markdown-grammer/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/markdown-grammer/</guid>
      <description>HTML 上标: Bull&amp;lt;sup&amp;gt;TM&amp;lt;/sup&amp;gt; BullTM
下标: H&amp;lt;sub&amp;gt;2&amp;lt;/sub&amp;gt;O H2O</description>
    </item>
    
    <item>
      <title>VIM Shorcuts</title>
      <link>/post/2021/04/06/vim-shorcuts/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/vim-shorcuts/</guid>
      <description>跳转命令 shift + g: 跳转到文件结尾
gg: 跳转到文件开头
:10: 跳转到第10行
删除命令 :1,10d: VIM模式下删除1～10行的内容
选中命令 v+j/k/h/l: 进入VISUAL模式，文本选中。
对于选中的文本可执行以下操作：
d: 剪切
y: 复制
p: 粘贴
0: 选中当前行，光标位置到行首
$: 选中当前行，光标位置到行尾
撤销与恢复 u: 撤销上一次操作
:redo: 恢复</description>
    </item>
    
    <item>
      <title>基于Hugo和Github Pages的个人博客搭建过程</title>
      <link>/post/2021/04/06/hugo-github-pages/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>/post/2021/04/06/hugo-github-pages/</guid>
      <description>撰写博文 使用RStudio IDE
blogdown::serve_site()命令，提供个人网站的本地实时渲染
blogdown::hugo_build()命令，在push给Github远程仓库之前，编译文件
可以在Vim中使用markdown语法对文本进行编辑</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>喜欢 心理学 友情链接 StriveZs的博客</description>
    </item>
    
  </channel>
</rss>
